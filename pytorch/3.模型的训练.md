

## 模型的加载和保存

1. `模型的保存`

   ```python
   import torch
   import torchvision
   
   vgg16 = torchvision.models.vgg16(pretrained=False)
   # 保存模型，方式1
   torch.save(vgg16, "vgg16_method1.pth")
   # 方式2，官方推荐
   torch.save(vgg16.state_dict(), "vgg16_method2.pth")
   ```

2. `模型的加载`

   ```python
   import torch
   import torchvision
   # 方式1加载模型
   model = torch.load("vgg16_method1.pth")
   print(model)
   
   # 方式2加载模型
   vgg16 = torchvision.models.vgg16(pretrained=False)
   vgg16.load_state_dict(torch.load("vgg16_method2.pth"))
   # model = torch.load("vgg16_method2.pth")
   print(vgg16)
   ```


## 训练

```
以cifar10数据集为例子，以下面的网络为例子
```

> ![image-20220705141649960](F:\Typora\pytorch\3.模型的训练.assets\image-20220705141649960.png)

- ` model.py 网络初始化`

    ```python
    import torch
    from torch import nn
    
    class Lzh(nn.Module):
        def __init__(self) -> None:
            super().__init__()
            self.model = nn.Sequential(
                nn.Conv2d(3, 32, 5, 1, 2),
                nn.MaxPool2d(2),
                nn.Conv2d(32, 32, 5, 1, 2),
                nn.MaxPool2d(2),
                nn.Conv2d(32, 64, 5, 1, 2),
                nn.MaxPool2d(2),
                nn.Flatten(),
                nn.Linear(64*4*4, 64),
                nn.Linear(64, 10)
            )
    
        def forward(self, x):
            x = self.model(x)
            return x
    
    if __name__ == '__main__':
        lzh = Lzh()
        input = torch.ones((64, 3, 32, 32))  # 这里的64是一个batch_size
        output = lzh(input)
        print(output.shape)
    ```

- `train.py 网络的训练`

  ```python
  import torchvision
  from torch.utils.data import DataLoader
  from torch.utils.tensorboard import SummaryWriter
  from model import *
  import torch
  
  train_data = torchvision.datasets.CIFAR10('./cifar10', train=True, transform=torchvision.transforms.ToTensor(),
                                           download=True)
  test_data = torchvision.datasets.CIFAR10('./cifar10', train=False, transform=torchvision.transforms.ToTensor(),
                                           download=True)
  
  # 数据集长度
  train_data_size = len(train_data)
  test_data_size = len(test_data)
  print("训练集的长度是{}".format(test_data_size))
  print("测试集的长度是{}".format(test_data_size))
  
  # 利用Dataloader加载数据集
  train_dataloader = DataLoader(train_data, batch_size=64)
  test_dataloader = DataLoader(test_data, batch_size=64)
  
  # 创建网路模型
  lzh = Lzh()
  
  # 损失函数
  loss_fn = nn.CrossEntropyLoss()
  
  # 优化器
  learning_rate = 1e-2
  optimizer = torch.optim.SGD(lzh.parameters(), lr=learning_rate)
  
  # 设置训练网络的一些参数
  # 记录训练的次数
  total_train_step = 0
  # 记录测试的次数
  total_test_step = 0
  # 训练的轮数
  epoch = 10
  
  writer = SummaryWriter("logs")
  
  for i in range(epoch):
      print("--------第 {} 轮训练开始".format(total_train_step))
  
      # 训练步骤开始
      for data in train_dataloader:
          imgs, targets = data
          outputs = lzh(imgs)
          loss = loss_fn(outputs, targets)
  
          # 优化器模型
          optimizer.zero_grad() # 把优化器的梯度清零
          loss.backward()
          optimizer.step()
  
          total_train_step = total_train_step + 1
          if total_train_step % 100 == 0:
              print("训练次数: {}, loss: {}".format(total_train_step, loss.item()))
              writer.add_scalar("train_loss", loss.item(), total_train_step)
  
      # 测试步骤
      total_test_loss = 0
      with torch.no_grad():
          for data in test_dataloader:
              imgs, targets = data
              outputs = lzh(imgs)
              loss = loss_fn(outputs, targets)
              total_test_loss = total_test_loss + loss.item()
  
      print("测试集上整体的loss：{}".format(total_test_loss))
      writer.add_scalar("test_loss", total_test_loss, total_test_step)
      total_test_step = total_test_step + 1
  
      # 保存每一轮的模型
      torch.save(lzh, "lzh_{}.pth".format(i))
      print("模型已保存")
  
  
  writer.close()
  ```

- `argmax函数`

  ```python
  # usage 把预测矩阵中的最大概率输出为 1
  argmax(0) 从矩阵的纵向看
  argmax(1) 从矩阵的横向看
  
  ```
  
  
  
## 利用GPU训练

```python
# 把 网络模型、训练数据、损失函数 放到cuda上即可
# 或直接使用torch.device把网络放在gpu上
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
lzh.to(device) # 网络
loss_fn.to(device)
# imgs = imgs.cuda()
imgs = imgs.to(device)
# targets = targets.cuda()
targets = targets.to(device)
```

## 模型的使用，验证

```python
from PIL import Image
import torchvision
from model import *

img_path = "imgs/dog.png"
img = Image.open(img_path)
print(img)

transform = torchvision.transforms.Compose([
    torchvision.transforms.Resize((32, 32)),
    torchvision.transforms.ToTensor()
])

img = transform(img)
# print(img)

model = torch.load("lzh_9.pth")
# model = torch.load("lzh_9.pth", map_location="cpu")
print(model)
img = torch.reshape(img, (1, 3, 32, 32))
model.eval()
with torch.no_grad():
    img = img.cuda()
    output = model(img)
print(output)
print(output.argmax(1))
```

- `使用resnet34网络验证`

  ```python
  import torchvision
  from torch import nn
  from torch.utils.data import DataLoader
  from torch.utils.tensorboard import SummaryWriter
  # from model import *
  import torch
  from torchvision.models import resnet34
  import os
  
  train_data = torchvision.datasets.CIFAR10('./cifar10', train=True, transform=torchvision.transforms.ToTensor(),
                                           download=True)
  test_data = torchvision.datasets.CIFAR10('./cifar10', train=False, transform=torchvision.transforms.ToTensor(),
                                           download=True)
  
  # 数据集长度
  train_data_size = len(train_data)
  test_data_size = len(test_data)
  print("训练集的长度是{}".format(test_data_size))
  print("测试集的长度是{}".format(test_data_size))
  
  # 利用Dataloader加载数据集
  train_dataloader = DataLoader(train_data, batch_size=64)
  test_dataloader = DataLoader(test_data, batch_size=64)
  
  # 定义训练的设备
  device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
  
  # 创建网路模型
  model = resnet34()
  model.to(device)
  
  # 损失函数
  loss_fn = nn.CrossEntropyLoss()
  # loss_fn.cuda()
  loss_fn.to(device)
  
  # 优化器
  learning_rate = 1e-2
  optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)
  
  # 设置训练网络的一些参数
  # 记录训练的次数
  total_train_step = 0
  # 记录测试的次数
  total_test_step = 0
  # 训练的轮数
  epoch = 20
  
  writer = SummaryWriter("logs")
  
  for i in range(epoch):
      print("--------第 {} 轮训练开始".format(total_train_step))
  
      model.train()
      # 训练步骤开始
      for data in train_dataloader:
          imgs, targets = data
          # imgs = imgs.cuda()
          imgs = imgs.to(device)
          # targets = targets.cuda()
          targets = targets.to(device)
          outputs = model(imgs)
          loss = loss_fn(outputs, targets)
  
          # 优化器模型
          optimizer.zero_grad() # 把优化器的梯度清零
          loss.backward()
          optimizer.step()
  
          total_train_step = total_train_step + 1
          if total_train_step % 100 == 0:
              print("训练次数: {}, loss: {}".format(total_train_step, loss.item()))
              writer.add_scalar("train_loss", loss.item(), total_train_step)
  
      # 测试步骤
      total_test_loss = 0
      total_accuracy = 0
      with torch.no_grad():
          for data in test_dataloader:
              imgs, targets = data
              # imgs = imgs.cuda()
              imgs = imgs.to(device)
              # targets = targets.cuda()
              targets = targets.to(device)
              outputs = model(imgs)
              loss = loss_fn(outputs, targets)
              total_test_loss = total_test_loss + loss.item()
              accuracy = (outputs.argmax(1) == targets).sum()
              total_accuracy = total_accuracy + accuracy
  
      print("测试集上整体的loss：{}".format(total_test_loss))
      print("测试集上整体的正确率：{}".format(total_accuracy/test_data_size))
      writer.add_scalar("test_loss", total_test_loss, total_test_step)
      writer.add_scalar("accuracy", total_accuracy/test_data_size, total_test_step)
      total_test_step = total_test_step + 1
  
      # 保存每一轮的模型
      model_save_path = os.path.join("./resnet_train_model", "resnet_train{}.pth".format(i))
      torch.save(model, model_save_path)
      print("模型已保存")
  
  
  writer.close()
  ```
  
  

