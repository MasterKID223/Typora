### 第四章-实验1_多线程和守护线程的扩展

**刘自航 3122351077**

#### 实验环境

Windows10、jdk-17、maven-3.8.8。

#### 实验目的

对第三章的RMI程序进行多线程和守护线程扩展。

#### 实现细节

使用多线程扩展：

```java
public class MainThread {

    public static void aain(String[] args) throws InterruptedException {
        System.out.println("英译汉RMI程序服务端启动...");
        System.out.println("=== 多线程实现：这是服务端的主线程 ===");
        Thread rmiThread = new Thread(() -> {
            System.out.println("+++ 服务端子线程：监听rmi请求 +++");
            try {
                TranslatorServiceImpl service = new TranslatorServiceImpl();
                Naming.rebind("rmi://localhost:56565/translate", service);
                System.out.println("英译汉RMI程序服务端启动成功。访问路径：rmi://localhost:56565/translate");
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println("+++++++++++++");
        });
        rmiThread.start();
        while (true) {
            Thread.sleep(10000);
            System.out.println("=== 主线程正在运行... ===");
        }
    }
}
```

使用守护线程扩展：

```java
public class MainDaemon {

    public static void aain(String[] args) throws InterruptedException {
        System.out.println("英译汉RMI程序服务端启动...");
        System.out.println("=== 守护进程实现：这是主线程 === ");
        Thread daemonThread = new Thread(() -> {
            try {
                System.out.println("+++ 服务端守护线程：监听rmi请求 +++");
                TranslatorServiceImpl service = new TranslatorServiceImpl();
                Naming.rebind("rmi://localhost:56565/translate", service);
                System.out.println("英译汉RMI程序服务端启动成功。访问路径：rmi://localhost:56565/translate");
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println("+++++++++++++");
        });
        daemonThread.setDaemon(true);  // 把子线程设置为守护进程
        daemonThread.start();
        while (true) {
            Thread.sleep(10000);
            System.out.println("=== 主线程正在运行... ===");
        }
    }
}
```

#### 运行结果

运行结果和第三章的运行结果一样，但是在服务端主线程运行结束后会有如下区别：

**守护线程监听rmi请求和用普通线程监听rmi请求的区别：**

RMI（远程方法调用）是 Java 提供的一种实现远程过程调用的机制。它允许一个 Java 应用程序通过网络调用另一个 Java 应用程序中的方法。在 RMI 中，服务端需要监听客户端的请求，从而能够响应客户端的调用请求。

在 RMI 中，服务端监听客户端请求的方式可以使用守护线程或者普通线程。两种方式的区别如下：

1. 生命周期

守护线程的生命周期与应用程序的生命周期相同。当应用程序退出时，所有守护线程会被自动终止。因此，如果使用守护线程来监听 RMI 请求，那么当应用程序退出时，服务端也会自动停止监听客户端请求。

而普通线程的生命周期则不同，它们会一直运行，直到执行完任务或者被中断。因此，如果使用普通线程来监听 RMI 请求，那么必须在应用程序退出时手动停止这些线程。

2. 可靠性

使用守护线程来监听 RMI 请求通常更可靠，因为它们会随着应用程序的退出而自动终止。这可以避免服务端程序在应用程序退出时出现一些异常情况，例如无法释放资源、无法终止等。

而使用普通线程来监听 RMI 请求则需要特别注意，在应用程序退出时必须正确地停止这些线程。否则，这些线程可能会继续运行，导致一些意想不到的问题。

3. 性能

使用守护线程来监听 RMI 请求通常比使用普通线程更高效，因为守护线程可以随时被操作系统中断，从而释放系统资源。而普通线程则需要等待任务完成或者被中断才能释放资源。

综上所述，如果需要在 Java 中监听 RMI 请求，建议使用守护线程来实现。这样可以简化代码，提高程序的可靠性和稳定性。
