### RMI

参考教程：[[w3c](https://www.w3cschool.cn/article/30445887.html)]

RMI（Remote Method Invocation）是一种Java技术，用于实现远程方法调用。RMI可以让一个Java应用程序通过网络调用另一个Java应用程序中的对象方法，就像调用本地对象方法一样简单。

RMI主要由两部分组成：远程接口和远程对象。远程接口定义了一个或多个方法，客户端可以通过这些方法来调用远程对象。远程对象实现了远程接口，并提供了实际的方法实现。

RMI的使用过程大致如下：

1. 定义远程接口：定义一个远程接口，并在接口中声明需要调用的远程方法。
2. 实现远程对象：实现远程接口，并提供方法的实现。同时，该远程对象需要继承自Remote接口，并标记为远程对象，以便RMI可以将其导出到远程JVM上。
3. 注册远程对象：将远程对象注册到RMI注册表中，以便客户端可以查找并调用该对象的方法。
4. 客户端调用远程方法：客户端通过远程接口来调用远程对象的方法，RMI会将请求发送到远程JVM上，并将结果返回给客户端。

RMI可以实现Java对象在不同的JVM之间的调用，使得Java应用程序能够跨越网络边界进行通信，非常适用于分布式系统中的对象通信。同时，RMI也提供了一些安全机制，如远程对象的访问权限、参数类型检查等，以保证通信的安全性和可靠性。

### UnicastRemoteObject类

这个类的具体作用，参考源码解释。

在 Java RMI 中，远程调用对象需要继承 `UnicastRemoteObject` 类，这是因为 Java RMI 实现了基于 Java 序列化的远程调用，需要在远程传输对象的过程中将对象序列化为字节流，然后在另一台计算机上进行反序列化，重新生成对象。

`UnicastRemoteObject` 类提供了一些默认实现，以便将对象转换为远程对象，并通过网络进行传输。如果一个远程对象没有继承 `UnicastRemoteObject` 类，那么它必须在构造函数中调用 `UnicastRemoteObject.exportObject()` 方法，以便将对象导出为远程对象，这样会增加代码的复杂性。

因此，为了简化代码并确保对象可以正确地进行远程传输，建议将远程调用对象继承 `UnicastRemoteObject` 类，这样就可以确保对象可以在远程计算机上进行传输，并且不需要在构造函数中显式调用 `UnicastRemoteObject.exportObject()` 方法。

```java
public class UserServiceImpl extends UnicastRemoteObject implements UserService {

    public UserServiceImpl() throws RemoteException {
    }

    @Override
    public User findUser(String userId) throws RemoteException {
        if ("1".equals(userId)) {
            User user = new User();
            user.setName("lzh");
            user.setAge(22);
            user.setSex("m");
            return user;
        }
        throw new RemoteException("查无此人");
    }
}
```

### dynamic object和named object

在分布式系统中，Dynamic Object 和 Named Object 都是用于远程对象访问和管理的机制。它们有一些相似之处，但也有不同点。

Dynamic Object 是指不具有静态名称和位置信息的对象，它们的存在和地址都是在运行时确定的。在动态对象模型中，对象的标识符是动态生成的，且可以随时更改，因此客户端无法在编译时确定要访问的对象，需要在运行时动态解析。Dynamic Object 的一个典型应用是 CORBA（Common Object Request Broker Architecture）中的动态组件模型。

Named Object 是指具有静态名称和位置信息的对象，它们可以在编译时确定并通过静态名称进行访问。在命名对象模型中，对象的标识符是静态生成的，且具有唯一的名称，因此客户端可以在编译时确定要访问的对象。Named Object 的一个典型应用是 Java RMI（Remote Method Invocation）中的命名服务模型。

在使用 Dynamic Object 和 Named Object 时，需要根据具体的应用场景和需求进行选择。如果对象的名称和位置在运行时需要动态确定，或者需要支持动态添加和删除对象，那么应该选择 Dynamic Object。如果对象的名称和位置在编译时就可以确定，并且需要支持静态绑定和查找，那么应该选择 Named Object。

### 守护进程

在操作系统中，守护进程（daemon）是一种长时间运行的后台进程，通常在系统启动时启动，并在系统关闭时停止。它们通常在后台执行任务，例如监视文件系统、网络连接、数据库等，以便在需要时执行操作。

在 Java 中，可以使用线程来实现守护进程。Java 中的线程分为用户线程和守护线程两种类型。当所有用户线程结束时，守护线程会自动退出。

要将线程设置为守护线程，可以使用 `setDaemon()` 方法。例如：

```java
javaCopy codeThread thread = new Thread(new Runnable() {
    public void run() {
        // 执行任务
    }
});
thread.setDaemon(true);
thread.start();
```

在上述示例中，创建了一个线程 `thread`，并将其设置为守护线程。然后通过 `start()` 方法启动线程。

需要注意的是，如果线程已经开始运行，那么将其设置为守护线程将不起作用。因此，应该在线程启动之前设置守护标志。

在 Java 中，一些常见的守护线程包括：

- 垃圾回收器线程：Java 中的垃圾回收器是通过守护线程实现的，用于自动回收不再使用的内存。
- 定时器线程：Java 中的定时器是通过守护线程实现的，用于执行定时任务。
- 终结器线程：Java 中的对象终结器是通过守护线程实现的，用于在对象被垃圾回收之前执行一些清理操作。

使用守护线程可以简化代码，提高程序的可靠性和稳定性。但是需要注意的是，如果守护线程执行任务的过程中发生了错误，那么可能会影响到整个程序的运行，因此需要谨慎使用。

### 守护线程监听rmi请求和用普通线程监听rmi请求有什么区别

RMI（远程方法调用）是 Java 提供的一种实现远程过程调用的机制。它允许一个 Java 应用程序通过网络调用另一个 Java 应用程序中的方法。在 RMI 中，服务端需要监听客户端的请求，从而能够响应客户端的调用请求。

在 RMI 中，服务端监听客户端请求的方式可以使用守护线程或者普通线程。两种方式的区别如下：

1. 生命周期

守护线程的生命周期与应用程序的生命周期相同。当应用程序退出时，所有守护线程会被自动终止。因此，如果使用守护线程来监听 RMI 请求，那么当应用程序退出时，服务端也会自动停止监听客户端请求。

而普通线程的生命周期则不同，它们会一直运行，直到执行完任务或者被中断。因此，如果使用普通线程来监听 RMI 请求，那么必须在应用程序退出时手动停止这些线程。

2. 可靠性

使用守护线程来监听 RMI 请求通常更可靠，因为它们会随着应用程序的退出而自动终止。这可以避免服务端程序在应用程序退出时出现一些异常情况，例如无法释放资源、无法终止等。

而使用普通线程来监听 RMI 请求则需要特别注意，在应用程序退出时必须正确地停止这些线程。否则，这些线程可能会继续运行，导致一些意想不到的问题。

3. 性能

使用守护线程来监听 RMI 请求通常比使用普通线程更高效，因为守护线程可以随时被操作系统中断，从而释放系统资源。而普通线程则需要等待任务完成或者被中断才能释放资源。

综上所述，如果需要在 Java 中监听 RMI 请求，建议使用守护线程来实现。这样可以简化代码，提高程序的可靠性和稳定性。