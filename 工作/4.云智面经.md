## 腾讯云智

### 面经1

https://www.nowcoder.com/feed/main/detail/ce433de34d3b4d78a4692bf09f8d6719?sourceSSR=search

项目
 1.可以从架构上去详细地去讲一下吗？
 2.数据库的主从复制你是怎么配置的？
 3.读写分离如何实现的？

2. 八股 

 1.能介绍一下那个进程线程和协程的区别吗？

当然可以！

进程（Process）、线程（Thread）、协程（Coroutine）是计算机编程中常用的并发编程概念，它们都是用来实现多任务处理的方式，但各自有着不同的特点和适用场景。

1. **进程（Process）**：
   - 进程是操作系统中的一个独立的运行单位，每个进程都有自己独立的内存空间、数据栈以及其他数据结构。
   - 进程之间的通信比较复杂，通常需要借助于操作系统提供的IPC（进程间通信）机制，如管道、消息队列、共享内存等。
   - 由于进程之间的资源是独立的，因此进程间的通信开销较大，但也更加稳定安全。

2. **线程（Thread）**：
   - 线程是进程中的一个实体，是CPU调度的最小单位，同一个进程中的多个线程共享该进程的内存空间和其他资源。
   - 线程之间的通信相对简单，可以通过共享内存等方式进行数据交换。
   - 由于线程共享进程的资源，因此线程间的通信开销较小，但需要注意线程安全问题。

3. **协程（Coroutine）**：
   - 协程是一种用户态的轻量级线程，由用户控制调度，而不是由操作系统调度。
   - 协程可以在同一个线程内实现并发，因此没有线程切换的开销，效率较高。
   - 协程之间的通信通过yield、send等方式进行，通常在同一个函数内部进行状态切换。

简单来说，进程是操作系统分配资源的基本单位，线程是CPU调度的基本单位，而协程则是程序员控制的一种轻量级线程，更适合于高并发、I/O密集型的场景。

 2.http 和 Https 的区别？

明文->密文，https加了ssl/tls协议

 3.有了解过https的加密流程吗？

tls的RSA算法的四次握手

 4.有了解过 DNS 解析的流程吗？

递归或者代理递归查询ip

 5.能讲一下 Java 的 Hashmap 的底层结构以及它的存储流程吗？ 

当然可以。HashMap 是 Java 中常用的数据结构之一，它基于哈希表实现。下面我会简要解释其底层结构和存储流程：

1. **底层结构**：
   HashMap 的底层结构主要由一个数组和链表（或红黑树）组成。数组的每个元素称为桶（bucket），每个桶可以存储一个或多个键值对。当多个键值对被映射到同一个桶时，它们会以链表（或红黑树）的形式存储在该桶中，以解决哈希冲突问题。

2. **存储流程**：
   - 当我们向 HashMap 中添加键值对时，首先会根据键的哈希码（通过调用键对象的 `hashCode()` 方法得到）来计算哈希值。
   - 哈希值经过哈希函数处理，确定该键值对应该放置在数组的哪个桶中。常用的处理方式是对数组长度取模，以保证哈希值落在合法范围内。
   - 如果目标桶为空，则将键值对直接存储在该桶中。
   - 如果目标桶非空，则意味着发生了哈希冲突。HashMap 会遍历该桶中的键值对，通过键对象的 `equals()` 方法找到具体的目标位置：
     - 如果找到的键对象与当前要插入的键对象相等，则更新对应的值。
     - 如果在链表中没有找到相等的键对象，则将新的键值对追加到链表的末尾。
     - 当链表长度达到一定阈值（默认为 8）时，链表会被转换为红黑树，以提高查找效率。
   - 如果在插入过程中数组大小达到了负载因子（默认为 0.75）的阈值，HashMap 会进行扩容操作。扩容会重新计算每个键值对的哈希值，并将它们重新分配到一个新的更大的数组中，以减少哈希冲突的可能性。

通过哈希表实现，HashMap 提供了常数时间的平均查找、插入和删除操作，是一种高效的数据结构，常被用于实现缓存、索引等功能。

 6.有了解过 Redis 吗啊？你这里也用过 Redis 是吧？ Redis 能解释一下，就是 Redis 里面缓存雪崩，缓存击穿和缓存穿透的概念以及解决方案吗



 7.sql语句的实现，两个表
   user id, name, sex, phone, address
   event id, userid, event
    7.1 在 user 表中找到姓名为张三，性别为难的用户的电话和地址。
    7.2 你对姓名为张三，性别为男的用户的电话和地址进行一个更新。

-  7.3 你根据这两条 SQL 给 user 表建立一个索引，会怎么建立?可以说一下在哪些字段，然后建立一个什么样的索引?

  在MySQL中，可以使用SQL语句来创建索引。索引可以大大提高查询的速度，特别是在对大型数据集进行检索时。下面是使用SQL语句在MySQL中创建索引的方法：

  创建索引

  1. **单列索引**：

  ```sql
  CREATE INDEX index_name ON table_name (column_name);
  ```

  例如，如果要在名为 `users` 的表上创建一个名为 `idx_username` 的索引，索引的列是 `username`，可以使用以下语句：

  ```sql
  CREATE INDEX idx_username ON users (username);
  ```

  2. **多列索引**：

  ```sql
  CREATE INDEX index_name ON table_name (column1, column2, ...);
  ```

  例如，如果要在名为 `products` 的表上创建一个名为 `idx_category_price` 的索引，索引的列是 `category` 和 `price`，可以使用以下语句：

  ```sql
  CREATE INDEX idx_category_price ON products (category, price);
  ```

  删除索引

  要删除索引，可以使用 `DROP INDEX` 语句：

  ```sql
  DROP INDEX index_name ON table_name;
  ```

  例如，如果要删除名为 `idx_username` 的索引，可以使用以下语句：

  ```sql
  DROP INDEX idx_username ON users;
  ```

  查看索引

  要查看表中的索引，可以使用 `SHOW INDEX` 语句：

  ```sql
  SHOW INDEX FROM table_name;
  ```

  例如，如果要查看名为 `users` 的表中的索引，可以使用以下语句：

  ```sql
  SHOW INDEX FROM users;
  ```

  这样就可以通过SQL语句在MySQL中创建、删除和查看索引了。在实际应用中，根据查询需求和数据特点合理创建索引，以提高查询效率。



​    7.4 如果我这里给 name 和 sex 建立一个联合索引的话，我只单独查询 name 可以命中索引吗？如果我单独查询 sex 可以命中索引吗？ 
​    7.5 写一下查询的一个SQL，然后你查到姓名为张三，性别为男。然后 event 为 login 的用户的电话和地址。

8. 给定一个长度为 n 的字符串，然后长度为 n 的字符串,这个字符串是由 1- 9 的数字组成，任意两个相邻的数字之和为10，则可以消除。（213792 -> 2192 -> 22） 输出字符串消除之后的长度，可以先说一下思路

### 面经2

https://www.nowcoder.com/feed/main/detail/3069ac93f9dd48b796b2fa23e3a3fde7?sourceSSR=search

3月19日 
一面

- Java 的三大特性你有什么理解吗

  当提到 Java 的三大特性时，通常指的是面向对象（Object-Oriented）、封装（Encapsulation）、继承（Inheritance）、多态（Polymorphism）。这些特性是 Java 语言设计的核心理念，下面我会简要解释一下每个特性的含义和作用：

  1. **面向对象（Object-Oriented）**：
     面向对象编程（OOP）是一种编程范式，它将现实世界中的事物抽象成对象，并通过对象之间的交互来完成程序的设计和实现。在 Java 中，一切皆为对象，程序由多个对象组成，对象通过相互发送消息来进行通信和交互。面向对象编程使得程序的设计更加模块化、可扩展和可维护。

  2. **封装（Encapsulation）**：
     封装是将数据（属性）和行为（方法）组合成一个单个单元，并对外部隐藏对象的内部细节。在 Java 中，封装通过访问修饰符（如 private、protected、public）来实现。封装有助于提高代码的可靠性和安全性，同时也降低了代码的耦合度，使得对象更容易被复用和维护。

  3. **继承（Inheritance）**：
     继承是一种机制，允许一个类（子类）基于另一个类（父类）的定义来定义自己的类。子类可以继承父类的属性和方法，并可以通过添加新的属性和方法来扩展父类的功能。继承提供了代码重用的机制，使得代码更加简洁和易于维护。

  4. **多态（Polymorphism）**：
     多态是指相同的操作或方法对不同的对象可以有不同的行为。在 Java 中，多态性可以通过方法的重载（Overloading）和方法的重写（Overriding）来实现。方法的重载是指在同一个类中定义多个同名方法，但参数列表不同；方法的重写是指子类重新定义了父类中已有的方法。多态性提高了代码的灵活性和可扩展性，使得程序能够更好地应对不同的需求和场景。

  这些特性使得 Java 成为一种强大的编程语言，广泛应用于各种领域的软件开发中。

- 那这三种特性带来什么好处呢？每一种分别带来什么好处？

- 然后你平常用了哪些集合类？

  在日常开发中，我经常使用以下几种 Java 集合类：

  1. **ArrayList**：
     ArrayList 是 Java 中最常用的动态数组实现，它提供了一个可以动态增长的数组，支持随机访问和快速插入/删除操作。ArrayList 是线程不安全的，适用于单线程环境或者在多线程环境中通过外部同步来保证线程安全。

  2. **HashMap**：
     HashMap 是一个基于哈希表的键值对存储实现，它提供了快速的查找、插入和删除操作。HashMap 允许键和值为 null，并且不保证元素的顺序。HashMap 是线程不安全的，可以通过 Collections.synchronizedMap() 方法或者 ConcurrentHashMap 来实现线程安全。

  3. **HashSet**：
     HashSet 是基于 HashMap 实现的，它是一个不允许有重复元素的集合。HashSet 通过哈希表存储元素，提供了快速的查找和插入操作。HashSet 也是线程不安全的，可以通过 Collections.synchronizedSet() 方法来实现线程安全。

  4. **LinkedList**：
     LinkedList 是双向链表的实现，它提供了快速的插入和删除操作，但是查找操作较慢。LinkedList 适用于需要频繁进行插入和删除操作的场景，但不适合需要随机访问的场景。LinkedList 是线程不安全的。

  5. **TreeMap**：
     TreeMap 是基于红黑树的有序映射实现，它可以保证元素按照键的自然顺序或者自定义顺序进行排序。TreeMap 提供了快速的查找操作，但插入和删除操作的性能较差。TreeMap 是线程不安全的，可以通过 Collections.synchronizedMap() 方法来实现线程安全。

  以上是我在日常开发中经常使用的几种集合类，根据具体的业务需求和性能要求，选择合适的集合类是很重要的。

- hashmap那你说一下的一个扩容机制 put方法

  HashMap 的扩容方案是在当前容量达到负载因子（Load Factor）乘以容量的阈值时进行的。默认情况下，负载因子的值为 0.75，这意味着当 HashMap 中的元素个数达到容量的 75% 时会触发扩容操作。

  HashMap 的扩容主要涉及以下步骤：

  1. **创建新数组**：
     当 HashMap 需要扩容时，它会创建一个新的数组，其大小通常是原数组的两倍。新数组的长度会选择成为大于或等于原数组长度的最小的 2 的幂。

  2. **重新哈希**：
     扩容时，HashMap 中的所有元素都需要重新分布到新的数组中。这个过程称为重新哈希。重新哈希是一个比较耗时的操作，因为它涉及将所有键值对重新计算哈希并放入新的桶中。

  3. **数据迁移**：
     为了避免元素之间的相对位置发生变化，HashMap 在扩容时会采用逐个迁移的方式。具体地，它会遍历原数组中的每个桶，将其中的键值对迁移到新数组对应的桶中。由于数组大小增加了一倍，相同哈希值的键值对可能会被分配到不同的桶中。

  4. **更新容量和阈值**：
     扩容完成后，HashMap 会更新其容量为新数组的长度，并根据新的容量重新计算扩容的阈值。新的阈值等于容量乘以负载因子。

  扩容是一项开销较大的操作，但它确保了 HashMap 在不断增加元素的情况下仍能保持较低的查找、插入和删除操作的时间复杂度。通过控制负载因子，可以平衡存储空间的利用率和性能之间的关系。

- Java 的异常分类

  在Java中，异常分为三种主要类型：受检异常（checked exceptions）、运行时异常（runtime exceptions）、和错误（errors）。

  1. **受检异常（Checked Exceptions）**：
     这些异常在代码中必须显式地处理，要么通过try-catch块捕获，要么通过在方法签名中声明抛出。受检异常是Exception类及其子类的实例，但不是RuntimeException的子类。典型的受检异常包括IOException（输入输出异常）、SQLException（数据库访问异常）等。

  2. **运行时异常（Runtime Exceptions）**：
     运行时异常是Exception类及其子类中不是受检异常的异常。与受检异常不同，它们在编译时不需要被显式地捕获或声明。典型的运行时异常包括NullPointerException（空指针异常）、ArrayIndexOutOfBoundsException（数组越界异常）、ClassCastException（类转换异常）等。

  3. **错误（Errors）**：
     错误表示了Java运行时环境无法处理的严重问题。与异常不同，错误通常是系统级的，无法通过代码捕获或处理。常见的错误包括OutOfMemoryError（内存耗尽）、StackOverflowError（栈溢出）等。

  理解这些异常的类型有助于编写更健壮的Java代码，并且能够更好地处理可能出现的问题，从而提高程序的可靠性和可维护性。

- Java 加锁有哪些方式

sleep和 wait 有什么区别吗

- 类的加载流程

  在Java中，类的加载过程遵循以下步骤：

  1. **加载（Loading）**：
     加载是指查找字节码文件（*.class文件），并从文件中加载类的二进制数据到内存中。这个过程由类加载器完成。在加载阶段，系统会根据类的全限定名来定位并读取相应的字节码文件。

  2. **链接（Linking）**：
     链接阶段包括三个子阶段：

     - **验证（Verification）**：确保被加载的类的字节码是合法且符合Java虚拟机规范的。这一步骤确保没有安全方面的问题。
     
     - **准备（Preparation）**：为类的静态变量分配内存，并将其初始化为默认值。这里不包括对静态变量赋予明确的初始值。
     
     - **解析（Resolution）**：将类、接口、字段和方法的符号引用转换为直接引用。在解析阶段，虚拟机会将常量池中的符号引用替换为直接引用，以便执行方法、字段等操作时能够准确地定位到相应的内存地址。

  3. **初始化（Initialization）**：
     初始化阶段是类加载的最后阶段，也是类加载过程中的最关键阶段。在这个阶段，Java虚拟机会执行类构造器 `<clinit>()` 方法。这个方法是由编译器自动生成的，用于初始化类的静态变量和执行静态代码块。如果一个类具有父类，JVM也会确保在执行子类的 `<clinit>()` 方法之前，先执行父类的 `<clinit>()` 方法。此外，初始化阶段是线程安全的，虚拟机会确保一个类的初始化只会被执行一次。

  这些阶段组成了Java类加载的整个流程。需要注意的是，类的加载并不是一次性的，它是按需进行的，即在程序中第一次使用某个类时才会进行加载。

- currentHashMap如何实现线程安全 

- cas机制

- threadlocal理解

  如上文所述，ThreadLocal 适用于如下两种场景

  1、每个线程需要有自己单独的实例
  2、实例需要在多个方法中共享，但不希望被多线程共享

线程池方法解决策略

设计模式

jvm 垃圾回收算法

Spring常用注解

aop和ioc

MySQL索引分类

MySQL引擎

事务隔离级别

mvcc

sql优化

redis数据结构

缓存击穿和雪崩

Redis 的一个备份流程吗？就是保存、刷刷内存固化到硬盘上，有哪些方式吗

tcp三次握手四次挥手

tcp和udp区别

项目问题

3月22日 
二面
项目问题

为什么redis单线程效率高



线程和进程的区别
tcp三次握手四次挥手
MySQL索引类型
MySQL引擎

- 布隆过滤器怎么实现 使用场景 怎么实现过滤

  布隆过滤器（Bloom Filter）是一种空间效率高、时间效率高的数据结构，用于判断一个元素是否可能存在于一个集合中。虽然布隆过滤器会有一定的误判率，但它在大规模数据集合中的查找效率非常高，因此在实际应用中被广泛使用。

  实现原理

  布隆过滤器的实现原理比较简单，它由一个位数组和多个哈希函数组成。具体步骤如下：

  1. 初始化：创建一个大小为m的位数组，将所有位都初始化为0。
  2. 插入：对于要插入的元素，将其通过多个哈希函数映射为位数组中的多个位置，并将这些位置的值设为1。
  3. 查询：对于要查询的元素，通过同样的哈希函数映射到位数组中的位置，检查这些位置的值，如果有任何一个位置的值为0，则可以确定该元素一定不在集合中；如果所有位置的值都为1，则该元素可能在集合中，但也可能是误判。

  使用场景

  布隆过滤器适用于以下场景：

  1. 缓存击穿：用于缓存中判断某个 key 是否存在。
  2. 防止缓存穿透：用于在查询前快速过滤掉不存在的 key。
  3. 分布式系统中的去重：用于在分布式系统中判断某个请求是否已经处理过。
  4. 避免查询数据库：用于在数据库查询之前快速过滤掉不可能存在的数据，减轻数据库压力。

  实现过滤

  实现过滤主要分为初始化、插入和查询三个步骤：

  1. **初始化**：创建一个大小为m的位数组，并初始化为0。
  2. **插入**：将要插入的元素通过多个哈希函数映射为位数组中的多个位置，并将这些位置的值设为1。
  3. **查询**：将要查询的元素通过同样的哈希函数映射到位数组中的位置，检查这些位置的值，如果有任何一个位置的值为0，则可以确定该元素一定不在集合中；如果所有位置的值都为1，则该元素可能在集合中，但也可能是误判。

  Python中可以使用第三方库如`pybloom_live`来实现布隆过滤器。示例代码如下：

  ```python
  from pybloom_live import BloomFilter
  
  # 初始化布隆过滤器，指定预期插入元素个数和误判率
  bf = BloomFilter(capacity=10000, error_rate=0.001)
  
  # 插入元素
  bf.add("apple")
  bf.add("banana")
  
  # 查询元素是否存在
  print("apple" in bf)  # True
  print("orange" in bf)  # False
  ```

  注意：误判率和位数组大小是布隆过滤器的两个重要参数，它们之间存在着权衡关系，可以根据实际情况进行调整。

Java多线程实现方法

- 类加载机制 它有什么好处 如何打破双亲委派

  动态加载类，对内存友好。

  翻译过来大概的意思是：

  > `ClassLoader` 类使用委托模型来搜索类和资源。每个 `ClassLoader` 实例都有一个相关的父类加载器。需要查找类或资源时，`ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。
  >  虚拟机中被称为 "bootstrap class loader"的内置类加载器本身没有父类加载器，但是可以作为 `ClassLoader` 实例的父类加载器。

  从上面的介绍可以看出：

  - `ClassLoader` 类使用委托模型来搜索类和资源。
  - 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
  - `ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。
  
  类加载机制是 Java 虚拟机（JVM）用来加载类文件的一种机制。它有助于确保 Java 应用程序在运行时能够正确地加载、链接和初始化类和接口。这种机制的主要好处包括：
  
  1. **命名空间隔离**：类加载器根据类的全限定名来加载类，不同的类加载器可以加载同名但是位于不同命名空间中的类，从而避免了类名冲突问题。
  
  2. **代码隔离**：通过使用不同的类加载器加载不同的类，可以实现代码的隔离，从而确保各个模块之间的独立性。
  
  3. **动态加载**：Java 的类加载机制支持动态加载，使得程序能够在运行时根据需要加载新的类，从而实现更加灵活的编程方式。
  
  双亲委派模型是类加载机制的一种常见实现方式，它通过层级结构的方式组织类加载器，并在加载类时按照一定的规则逐级向上委派，直到顶层的启动类加载器。这种模型的好处在于确保类的唯一性和安全性，同时也提高了类加载的效率，避免了类的重复加载。
  
  有时候，我们可能需要打破双亲委派模型。这通常发生在一些特殊的需求场景下，比如在某些类加载器环境中需要加载不同版本的同一个类。要打破双亲委派模型，一种常见的方式是通过创建自定义的类加载器，并在加载类时自行实现加载逻辑，而不是按照双亲委派的方式。这样可以实现更加灵活的类加载策略，但也需要开发人员自行确保类加载的正确性和安全性。

jdbc
jvm垃圾回收算法

- 场景题 如果项目运行cpu超过90%如何排查

  当项目运行时 CPU 使用率超过 90% 可能会导致性能问题，需要进行排查。下面是一些可能的排查步骤：

  1. **监控工具**：使用系统监控工具（如top、htop、Windows任务管理器等）来实时监视系统的 CPU 使用情况，确认 CPU 使用率是否真的超过了 90%。

  2. **定位高负载进程**：确定哪个进程或者线程占用了大量的 CPU 资源。这可以通过监控工具或者系统的进程管理工具（如ps命令）来查看。

  3. **分析高负载进程**：一旦确定了高负载的进程，就需要分析其活动。使用工具（如jstack、jconsole、VisualVM等）来分析 Java 进程中的线程堆栈信息，找出哪些线程正在消耗 CPU 资源。

  4. **性能剖析工具**：使用性能剖析工具（如Java Flight Recorder、Async Profiler、YourKit等）来分析程序的性能瓶颈。这些工具可以帮助你找出代码中的热点，从而定位到造成 CPU 使用率高的原因。

  5. **代码审查**：检查代码是否存在性能问题，比如循环过多、不必要的计算、线程阻塞等。优化代码可以有效地降低 CPU 使用率。

  6. **资源利用情况**：检查项目使用的其他资源，比如内存、网络带宽等，是否也存在问题。有时候 CPU 使用率高可能是因为其他资源的限制导致的。

  7. **系统参数调整**：根据具体情况调整系统参数，比如调整线程池大小、调整 JVM 参数等，以优化系统的性能。

  8. **升级硬件**：如果以上方法都无法解决问题，可能需要考虑升级硬件，比如增加 CPU 核心数或者提高 CPU 主频。

  以上是一些常见的排查方法，具体的排查步骤会根据项目的具体情况而有所不同。

算法题 LRU
3月25日 
hr面
4月2日
发offer

### 面经3

https://www.nowcoder.com/feed/main/detail/016eb9c72b32462e9680c2705691e5a3?sourceSSR=search

面试官很和气、也很包容 面试体验感很不错
我说说都问了什么吧
1 开始进行自我介绍
2 接着看我的项目里面亮点开始深究
3 线程池的创建方式有几种， 什么时候会用到线程池
4 项目中用到了hashMap 吗具体说说，并说说底层的实现
5 Redis 是怎样解决缓存击穿、缓存穿透的 以及为什么会出现这种现象
6 怎样解决数据库的一致性问题
7 为什么要使用redis 和 mysql 相结合的策略
8 了解计算机网络吗，说说三次握手四次挥手 TCP以及UDP
9 你说你的研究方法是python 用的比较多，那么python的判断不等于的时候 is not 和 ！= 有什么区别
10 了解大数据吗，大数据里面的组件名词都有啥

### 面经4

https://www.nowcoder.com/feed/main/detail/bae549f1f80746b69b8979e34a63bdff?sourceSSR=search

1.自我介绍

- 3.给你一个场景，我有一个几G的大文件然后拆分为小文件上传比如5-10M然后程序一直full gc有哪些解决方案只要从JVM角度来讲?(太菜了只会调堆和新生代)

  在处理大文件上传并拆分为小文件时频繁发生 Full GC（Full Garbage Collection）可能是由于内存占用过高导致的。以下是一些从 JVM 角度来解决这个问题的建议：

  1. **调整堆内存大小**：默认情况下，JVM 分配给堆内存的大小可能不够应对大文件上传和拆分操作。你可以通过 `-Xms` 和 `-Xmx` 参数来调整初始堆大小和最大堆大小。增大堆内存可以减少频繁的 Full GC。但是请注意，过大的堆内存也可能会导致长时间的 GC 暂停，因此需要权衡。

  2. **调整新生代大小**：大文件上传过程中产生的大量临时对象可能会导致新生代内存快速填满，触发频繁的 Minor GC。你可以通过 `-Xmn` 参数来调整新生代的大小，以容纳更多的临时对象，减少 Minor GC 的频率。

  3. **优化对象的创建和销毁**：尽量减少临时对象的创建，特别是在循环或者频繁调用的地方。如果可能的话，可以重用对象，避免频繁的垃圾回收。

  4. **使用并发 GC**：考虑使用并发垃圾收集器（如CMS、G1等），它们可以在 GC 进行时并发地执行部分应用程序线程，减少 GC 导致的停顿时间。

  5. **分析内存泄漏**：如果 Full GC 频繁且没有明显的原因，可能存在内存泄漏。你可以使用内存分析工具（如VisualVM、MAT等）来分析堆内存的使用情况，找出潜在的内存泄漏问题。

  6. **增加物理内存**：如果可能的话，增加系统的物理内存可以缓解内存压力，减少频繁的垃圾回收。

  7. **减少文件上传和拆分操作的内存占用**：优化文件上传和拆分的算法，尽量减少内存的使用。可以考虑使用流式处理方式，逐行读取和处理文件，而不是一次性读取整个文件到内存中。

  综合考虑以上因素，你可以选择适合你应用程序的解决方案，以减少 Full GC 的频率，提高系统的性能和稳定性。

  在Java虚拟机的内存管理中，堆被划分为两个主要部分：新生代和老生代。

  1. **新生代（Young Generation）**：新生代是堆内存的一部分，用于存放新创建的对象。在新生代中，又被分为 Eden 空间和两个 Survivor 空间（通常称为 From 和 To 区）。大部分对象在新生代中被创建，并且在短时间内就被回收。垃圾收集器通常会选择在新生代中进行Minor GC，来回收这些短时间内死亡的对象。

  2. **老生代（Old Generation）**：老生代用于存放存活时间较长的对象。一些新生代中的对象经过多次Minor GC后，如果仍然存活，就会被移动到老生代。老生代中的对象相对较少，但它们的生命周期较长。垃圾收集器通常会选择在老生代中进行Full GC，以回收老年对象的内存。

  这两个部分构成了Java堆的主要组成部分。堆是Java虚拟机管理的最大的一块内存，用于存储对象实例和数组，因此在Java应用程序中，堆内存的分配和回收对于应用程序的性能和稳定性至关重要。

- 2.JVM了解过吗讲讲你了解的(只会内存模型，垃圾回收算法，新生代老年代)

  当然了，我对 JVM（Java虚拟机）非常了解。JVM 是 Java 程序的运行环境，负责将 Java 字节码转换为机器码并执行程序。以下是我对 JVM 的一些了解：

  1. **架构**：JVM 的架构主要包括类加载器、运行时数据区、执行引擎和本地方法接口等组件。运行时数据区包括方法区、堆、虚拟机栈、本地方法栈和程序计数器。

  2. **类加载器**：类加载器负责将类文件加载到内存中，并转换为 JVM 内部表示的类结构。JVM 包括三种类加载器：启动类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）和应用程序类加载器（Application Class Loader）。

  3. **运行时数据区**：运行时数据区包括堆、方法区、虚拟机栈、本地方法栈和程序计数器。堆用于存放对象实例和数组，方法区用于存放类的结构信息，虚拟机栈和本地方法栈用于执行方法时的局部变量表、操作数栈和方法返回值等信息，程序计数器用于记录线程执行的当前字节码指令地址。

  4. **垃圾收集器**：JVM 包括不同类型的垃圾收集器，用于自动回收不再使用的对象，并释放内存空间。常见的垃圾收集器包括串行收集器、并行收集器、CMS（Concurrent Mark-Sweep）收集器、G1（Garbage-First）收集器等。

  5. **即时编译器（JIT Compiler）**：JVM 包括即时编译器，用于将 Java 字节码转换为本地机器码，以提高程序的执行速度。JIT 编译器可以将频繁执行的代码段编译为本地代码，并进行优化。

  6. **内存管理**：JVM 负责管理 Java 程序的内存分配和回收。JVM 使用垃圾收集器来回收不再使用的对象，并通过内存分配器来分配对象实例的内存空间。

  7. **性能监控与调优**：JVM 提供了丰富的性能监控和调优工具，如JVisualVM、JConsole、Java Mission Control等，用于监控程序的内存使用、垃圾回收情况、线程运行情况等，并通过调整 JVM 参数来优化程序的性能。

  总的来说，JVM 是 Java 程序运行的核心，它提供了内存管理、垃圾回收、即时编译等功能，保证了 Java 程序的跨平台性、安全性和高性能。

4.常用哪些集合?
5.HashMap介绍(老八股)
6.为什么8，64转红黑树，这个取值怎么决定的。
7.HashMap在并发有什么问题(讲了死循环，没答好让我回去多看看)

- 8.ConcurrentHashMap介绍一下1.8，采用什么锁，获取长度需要加锁吗

  在Java 8中，ConcurrentHashMap是一个线程安全的哈希表实现，旨在支持高并发的读写操作。它采用了一种称为分段锁（Segment Locking）的机制来提高并发性能。

  在ConcurrentHashMap中，哈希表被分成多个段（Segment），每个段相当于一个小的哈希表，拥有自己的锁。这样不同的线程可以同时访问不同段的数据，从而减少了锁的竞争，提高了并发性能。

  在Java 8中，ConcurrentHashMap的长度并不需要加锁来获取。相反，它使用了一个`sizeCtl`字段来表示表的大小状态。`sizeCtl`字段的值可以有不同的含义，例如：

  - 如果`sizeCtl`是负数，表示表正在进行扩容操作，这时需要额外的同步机制来确保扩容的正确进行。
  - 如果`sizeCtl`是正数或零，表示表的大小，这时获取长度不需要额外的加锁操作。

  因此，获取ConcurrentHashMap的长度是一个非常高效的操作，不需要加锁。

- 9.讲讲synchronized的锁升级(吟唱无锁->偏向->轻量->重量)

  在Java中，`synchronized`关键字用于实现线程同步，保证多个线程对共享资源的安全访问。`synchronized`锁是重量级锁，但它具有一种优化机制，称为锁升级，以提高性能。

  锁升级是指在`synchronized`关键字的语义中，锁的状态从无锁状态逐渐升级为偏向锁、轻量级锁，最终升级为重量级锁的过程。

  1. **偏向锁（Biased Locking）**：当一个线程第一次进入同步代码块时，会尝试获取偏向锁。如果没有竞争，该线程会成功获得锁，并将对象头的标记设置为指向当前线程。这样后续进入同步代码块的线程就可以直接检查对象头，发现锁已经被当前线程持有，从而省略了大部分同步操作。偏向锁适用于大部分情况下只有一个线程访问同步块的场景。

  2. **轻量级锁（Lightweight Locking）**：当有多个线程竞争偏向锁时，偏向锁会升级为轻量级锁。轻量级锁使用CAS操作来尝试获取锁，如果竞争失败，则会自旋等待一段时间，尝试获取锁。如果自旋失败，锁会升级为重量级锁。

  3. **重量级锁（Heavyweight Locking）**：当自旋等待也失败时，锁会升级为重量级锁。重量级锁会让线程进入阻塞状态，释放CPU资源，直到获得锁的线程释放锁为止。

  锁升级的目的是在不同场景下选择合适的锁机制，以提高性能。在大部分情况下，偏向锁和轻量级锁的开销比重量级锁小，因此能够减少线程的竞争和上下文切换，提高程序的并发性能。

10.线程池(问了默认线程池有什么bug，一开始忘记了任务队列可以一直加然后撑爆)
11.Redis在项目怎么用的(缓存+签到+限流)

- 12.Redis常用命令讲讲

  Redis是一个开源的内存数据库，它支持多种数据结构，包括字符串、哈希表、列表、集合、有序集合等，并提供了丰富的命令集用于对这些数据结构进行操作。以下是Redis中常用的一些命令：

  1. **字符串操作**：
     - `SET key value`：设置指定键的值。
     - `GET key`：获取指定键的值。
     - `DEL key`：删除指定的键。
     - `INCR key`：将指定键的值增加1。
     - `DECR key`：将指定键的值减少1。

  2. **哈希表操作**：
     - `HSET key field value`：为指定键的哈希表中设置字段的值。
     - `HGET key field`：获取指定键的哈希表中指定字段的值。
     - `HDEL key field [field ...]`：删除指定键的哈希表中的一个或多个字段。
     - `HGETALL key`：获取指定键的哈希表中所有字段和值。

  3. **列表操作**：
     - `LPUSH key value [value ...]`：将一个或多个值插入到列表的头部。
     - `RPUSH key value [value ...]`：将一个或多个值插入到列表的尾部。
     - `LPOP key`：移除并返回列表的第一个元素。
     - `RPOP key`：移除并返回列表的最后一个元素。

  4. **集合操作**：
     - `SADD key member [member ...]`：向集合添加一个或多个成员。
     - `SMEMBERS key`：返回集合中的所有成员。
     - `SREM key member [member ...]`：移除集合中一个或多个成员。
     - `SINTER key [key ...]`：返回给定所有集合的交集。

  5. **有序集合操作**：
     - `ZADD key score member [score member ...]`：将一个或多个成员添加到有序集合，或更新已存在成员的分数。
     - `ZRANGE key start stop [WITHSCORES]`：通过索引区间返回有序集合的成员。
     - `ZREM key member [member ...]`：移除有序集合中一个或多个成员。

  6. **键操作**：
     - `EXPIRE key seconds`：设置键的过期时间。
     - `TTL key`：获取键的剩余过期时间。
     - `KEYS pattern`：查找所有符合给定模式的键。

  这只是Redis中的一小部分常用命令，Redis提供了更多丰富的命令和功能，可以根据具体的需求进行选择和使用。

13.讲讲令牌桶算法
14.为什么要用Redis，本地不也可以实现限流吗,
15.Mysql的innodb的数据结构，B树和B+树区别。
16.慢SQL怎么优化(本来想从日志->网络->explain，只让说explain)
17.索引失效场景
18.组合索引abcd，给abc，bca，bcd，adc谁命中了(讲了key len)
19,为什么说最左匹配不匹配就不走索引(从非聚簇索引树结构讲)20.讲讲MVCC

### 面经4

https://www.nowcoder.com/discuss/604967014662172672?sourceSSR=post

详细说Mysql事务

MVCC

隔离级别

存储引擎

如何优化sql

失效场景

什么是行锁，两个线程同时去写一条数据会发生什么

jwt的作用，为什么使用jwt

为什么使用redis

- redis缓存一致性怎么保证

  一般是先删除数据库，再删除缓存。

- 延迟双删

  延迟双删（Delayed Double Delete）是一种用于解决缓存与数据库不一致性问题的一种策略。在这种策略中，当数据从数据库中删除时，不立即删除缓存中的相应数据，而是先将缓存中的数据标记为过期，然后延迟一段时间再进行真正的删除操作。

  延迟双删的核心思想是通过延迟缓存的删除操作，给系统一段时间来处理可能的读写操作，确保数据的一致性。延迟双删可以避免以下情况导致的数据不一致性：

  1. **缓存雪崩**：当大量缓存同时失效时，会导致大量的请求直接访问数据库，造成数据库压力过大，甚至宕机。延迟双删可以在一定程度上减轻这种情况的发生，因为不会立即删除缓存，而是将其标记为过期，然后在一段时间内逐渐删除。

  2. **缓存穿透**：当请求的数据在缓存中不存在，但是在数据库中也不存在时，会导致大量的请求直接访问数据库，同样会造成数据库压力过大。延迟双删可以在一定程度上缓解这种情况，因为即使请求的数据在数据库中不存在，也不会立即删除缓存，而是延迟一段时间再进行删除。

  延迟双删的实现通常依赖于定时任务或者异步任务队列。在数据从数据库中删除后，会启动一个定时任务或者将一个异步任务加入队列，在一定的延迟时间后再去真正删除缓存中的数据。这样可以给系统一定的缓冲时间，以处理可能的读写操作，从而保证数据的一致性。

解释下什么并发

并发问题如何解决

是否了解乐观锁悲观锁

### 面经5

https://www.nowcoder.com/discuss/601177644956168192?sourceSSR=post

自我介绍

发布订阅模式的优点是什么？缺点是什么？如果让你来实现类似MQTT的功能，你需要考虑哪些方面？

TCP粘包拆包实现原理？如果让你来实现，你会怎么设计？

为什么用数据库连接池？如果数据库支持的最大连接数满了，怎么操作？（高可用）如果让你来设计一个数据库连接池，你会考虑什么因素？为什么？

介绍IoC、DI、AOP原理？

介绍一下红黑树？查询效率？时间复杂度？

进程、线程的区别是什么？

项目中用过Git分支吗？介绍一下？

如何解决哈希冲突？

红黑树？时间复杂度？

- 什么原因导致I/O阻塞？

  I/O（输入/输出）阻塞可能由多种原因导致，其中一些常见的包括：

  1. **文件系统操作**：当程序试图读取或写入文件时，如果文件系统速度较慢或者文件过大，可能会导致I/O阻塞。

  2. **网络通信**：如果程序需要从网络中读取数据或向网络发送数据，网络速度慢或网络延迟高可能导致I/O阻塞。

  3. **设备交互**：与硬件设备（如硬盘驱动器、打印机、传感器等）进行通信时，可能会发生I/O阻塞，尤其是在设备繁忙或通信速度慢时。

  4. **数据量大**：如果程序需要处理大量数据，而处理速度不足以跟上数据的输入或输出速度，可能会发生I/O阻塞。

  5. **并发访问**：当多个进程或线程尝试同时访问共享资源（如文件、网络连接）时，可能会发生I/O阻塞，因为某个进程或线程正在使用资源而其他进程或线程需要等待。

  6. **资源竞争**：当多个进程或线程竞争访问同一资源时，可能会导致I/O阻塞，因为某个进程或线程持有资源而其他进程或线程无法访问。

  通过优化代码、使用异步I/O、增加缓存、使用多线程或多进程等方法，可以减少I/O阻塞对程序性能的影响。

编程题，翻转单词：“I am a student.” 翻转成 “student. a am I”。 要求：不允许使用Java内置函数

### 面经6

https://www.nowcoder.com/discuss/604970666676191232?sourceSSR=users

腾讯云智一面（秒挂）——3.28
项目+八股（25min）
部门

腾讯会议后台研发中心

1.自我介绍

2.介绍项目（黑马点评）

3.项目负责部分

4.项目的表结构设计

5.缓存优化这块针对的表及表结构

6.该表的索引（除了主键索引，还有别的索引吗）

7.索引的原理

8.缓存怎么做的（黑马的商家信息的缓存）

​    在redis中存多久

​    更新时怎么更新

​    当更新redis失败时，两边数据不一致怎么办

​    这里使用的是redis的哪个数据结构

​    redis还有什么数据结构

9.讲讲redis为什么查询会比较快

10.介绍秒杀功能（最终实现）

​    怎么判断是否有购买资格

​    redis挂了怎么办（这块持久化是如何实现的）

11.登录

​    双拦截器的作用

12.MySQL的事务机制

13.幻读是什么

14.不可重复读

15.如何避免幻读和不可重复读

16.线程池的原理

17.hashmap的数据结构

18.在网站输入地址回车后会经过哪些协议

19.tcp和udp的区别

20.tcp如何保证可靠性

21.三次握手

反问

1.几面（三面技术+HR）

2.评价

​    项目掌握不深

​    基础还不熟

​    数据结构掌握还可以

### 面经7

https://www.nowcoder.com/feed/main/detail/de8a90b8e46a4dbbb92fb169c553641b?sourceSSR=search

4.10 腾讯云智-西安 80min
1.手撕算法 两个 ：

编写一个函数，实现一个随机字符串；

两个数组找交集，说思路：先说了利用set，然后遍历另一个数组。面试官反问，那不申请其它空间怎么实现？我说排序，然后遍历数组。面试官：好，那你用快排实现吧，你可以手写快排吗？ 我说可以。。

   （两个算法题一共写了将近40分钟）

  写完还让我自己调试用例，还问我怎么优化，然后还不给我思考的时间555555555

2.自我介绍

3.列举5个你熟悉的排序算法 并说出思路 讲了快排 堆排 简单选择 冒泡 

4.tcp三次握手，客户端和服务端分别发送什么数据？客户端服务端分别是什么状态？只答出了第一点。

5.linux中的通信方式有哪些？ 不会

6.了解过epoll吗？怎么实现的？ 扯了redis中的io多路复用

7.epoll的触发机制有哪些？ 不会

8.linux内存淘汰机制有哪些？说了LRU，LFU，ttl，随机

9.linux的分页和分段了解过吗？。。。。。。。。。。linux这块我基本就没怎么看 根本不会5555

10.数据库的存储引擎有哪些？讲一下区别？

- 11.B+树删除一个元素和增加一个元素的时间复杂度是多少？

  B+树的删除和插入操作的时间复杂度通常为 \( O(\log n) \)，其中 \( n \) 是B+树中的节点数量。

  1. **插入操作的时间复杂度**：在B+树中插入一个元素，需要从根节点开始，依次向下查找到合适的位置进行插入，并且可能需要进行节点分裂操作，使得整个树保持平衡。因为B+树的高度通常为 \( O(\log n) \)，所以插入操作的时间复杂度为 \( O(\log n) \)。

  2. **删除操作的时间复杂度**：删除操作也需要从根节点开始，依次向下查找要删除的元素，然后进行删除操作，并可能需要进行节点合并或者重新分配元素，以保持树的平衡。因此，删除操作的时间复杂度也为 \( O(\log n) \)。

  需要注意的是，这里的时间复杂度是基于B+树的平衡状态下的情况。在某些情况下，可能会有额外的开销，比如节点的分裂或合并可能会导致更多的操作，但总体来说，B+树的插入和删除操作通常是 \( O(\log n) \) 的。

12.mysql最左匹配原则。讲了原理以及什么情况下会失效。

13.为什么会失效？ 讲了B+树叶节点的结构。

14.mysql的慢查询用过吗 ？有什么优化思路。 我说了优化数据表结构，优化sql语句。讲着讲着面试官说：好了，看来你没用过，你应该是看过这方面的文章吧，然后打断我不让我说了…………

面试体验：

面试官人狠话不多 上来就手撕代码给我一个下马威，然后问的知识点里面linux的我基本都不太会，没怎么复习过。。。java八股一个也没问，他说他们部门要写go和php，还问我转语言能不能接受，我说能。

但是总体感觉还是挂了 操作系统的部分基本没答上来……

### 面经8

https://www.nowcoder.com/feed/main/detail/aaf8d67814f74a2a9b6d5ab5cb2c63d0?sourceSSR=search

1.自我介绍(竟然没有项目拷打，震惊)
2.介绍下在得物做了啥
3.简单算法题-一个字符串中最长不重复的子串(a出来了）
4.拿笔和纸，给你中序和后序，给出前序(好久之前做的，只写出来二叉树前几个，可能写太久了，叫停我，直接给答案了）
5.map和set区别
6.http和https区别
7.进程和线程，介绍下
8.多线程高并发讲一下
9.threadlocal中怎么保存数据，底层说一下
10.线程之间怎么传输数据
11.双亲委派机制讲讲，作用说一下
12.类似双亲委派机制这种设计模式是哪种
13.单例模式讲讲，饿汉式、懒汉式的缺点
反问:只有西安有岗位吗(他这里是只招西安那块的)，
我笔试做的并不是很好，怎么进面了(今早刚拿到我的面试，基础还得加强😂)，多久出结果(一两天，两三天吧)
好像还有点，记不全了，有新的补充，全程拷打50分钟，计网操作系统那块答得不好，Java部分回答的还行，希望能过吧，云智我还是蛮想去的。

### 设计模式





### JVM

#### 垃圾回收



#### 内存模型



#### 类加载器





### 面经9-二面

https://www.nowcoder.com/discuss/607295069766291456?sourceSSR=search

腾讯云智客户端二面面经
约面了半小时，实际时间也差不多，在 38 分钟左右，主要是做两个算法，一个快排、一个二维 dp，面试官肯定不是 Java 的然后问的 408，面试官让等后续面试，不知道几轮。

1）自我介绍？

面试官：先来个简单的自我介绍吧？

我：xxxx，现在自我介绍开始乱讲.jpg。以前说的比较全，现在主打一个特点，开源项目千 Star + 书籍阅读情况，建议按时间顺序去讲就可以了，大一学了xxx，有xxx成就，为什么要做？做了的结果是什么？自己有什么成长？围绕这几个点展示

2）设计模式？

面试官：你了解哪些设计模式？

我：单例、简单工厂、静态工厂、抽象工厂、策略、适配器、门面（外观）、注册器、装饰器，xxxx 不报菜名了，重点提及项目实践过相关设计模式即可，因为下一个问题大概率就是~。

3）项目设计模式实践

面试官：你项目用到了哪些设计模式？

我：这边简略说一下，大概是门面模式，然后结合 CompletableFuture，并行获取三个不同的接口，没有先后顺序，用 allOf.Join()，然后 CompletableFuture 形参可以放线程池，会线程池的话可以引导一波，一个题可以一直延伸，但可以适可而止，看面试官会不会打断，我一般说的差不多就主动中止.jpg，可以适当留下点问题。

4）实习这边就不细说了，没问什么详细的东西，入职没多久，混子一个~

5）学校课程学习？

面试官：学校学过哪些课程？

我：408，主要引导计算机网络、操作系统、计算机组成原理、数据结构，其他课程也能讲，面试官肯定不问，计网+操作系统基本是必问项，无论是哪个方面，后端？客户端？前端？测试？测开？都可以问基础.jpg。我建议是牛客有几千道题，能刷烂 408 和 Linux ，并且把 Guide 和 小林的看完，基本是理论这块可以说是入门了，实践题还是得自己动手。

6）TCP 连接过程

面试官：说说 TCP 连接过程？

我：是三握四挥吗？得到肯定回答，这边直接背个流程图两张就可以了，然后你想讲一些额外的延伸也行，引出 UDP ？引出 OSI 模型？只要是计网的，越底层越好.jpg。

7）HTTP 和 HTTPS 的区别？

面试官：介绍下 HTTPS？

我：思路，先介绍 HTTP 和 HTTPS 的区别，端口？协议？加密过程？粗略介绍，比如项目我申请了 SSL 证书，怎么申请的？怎么上传的？密文？明文？CA？很多知识点可以被提到，因为后续必问这些，尽量将自己能 cover 主的概念，因为后续会深入，假如你不会加密算法，尽量别引导就是了。

8）HTTPS 加密过程？

面试官：HTTPS 加密过程说一下？

我：按流程图记忆，图像记忆>文字，可以自己绘制，思维导图？流程图？时序图？功能图？加密算法可以说一下，后续要问也行。

9）做题....

面试官：有刷题吗？题量？

我：有有，不多，几百道...不敢说多，我怕 hard 两个。

第一题是快速排序，边界搞了几分钟...大概点了10次运行，没蚌住，第一次是区间越界，然后递归栈溢出。

第二题最长回文子串，二维dp，做完了，然后发现第二次测试用例不对，调了2,3分钟，也解决了。

10）HashMap 线程安全吗，后续加了个问题，答完收工了。

11）面试官问业余时间干什么，自由发挥即可~学习和非学习都讲。

12）反问面试表现和建议，然后面试官问 base 地点的问题。

### 面经10

https://www.nowcoder.com/feed/main/detail/bae549f1f80746b69b8979e34a63bdff?sourceSSR=search

1.自我介绍
3.给你一个场景，我有一个几G的大文件然后拆分为小文件上传比如5-10M然后程序一直full gc有哪些解决方案只要从JVM角度来讲?(太菜了只会调堆和新生代)
2.JVM了解过吗讲讲你了解的(只会内存模型，垃圾回收算法，新生代老年代)
4.常用哪些集合?
5.HashMap介绍(老八股)
6.为什么8，64转红黑树，这个取值怎么决定的。
7.HashMap在并发有什么问题(讲了死循环，没答好让我回去多看看)
8.ConcurrentHashMap介绍一下1.8，采用什么锁，获取长度需要加锁吗
9.讲讲synchronized的锁升级(吟唱无锁->偏向->轻量->重量)
10.线程池(问了默认线程池有什么bug，一开始忘记了任务队列可以一直加然后撑爆)
11.Redis在项目怎么用的(缓存+签到+限流)
12.Redis常用命令讲讲
13.讲讲令牌桶算法
14.为什么要用Redis，本地不也可以实现限流吗,
15.Mysql的innodb的数据结构，B树和B+树区别。
16.慢SQL怎么优化(本来想从日志->网络->explain，只让说explain)
17.索引失效场景
18.组合索引abcd，给abc，bca，bcd，adc谁命中了(讲了key len)
19,为什么说最左匹配不匹配就不走索引(从非聚簇索引树结构讲)20.讲讲MVCC

### 面经11-二面

https://www.nowcoder.com/discuss/607912169136484352?sourceSSR=search

腾讯云智后端暑期实习二面
自我介绍
讲一下做的这个项目
项目里Redis怎么用的，放的什么
缓存的雪崩，穿透，击穿的处理方案
项目里RocketMQ怎么用的
发送消息时消息丢失怎么办
消息的可靠性怎么保证
你为什么要分库分表，怎么分的
进程，线程，协程的区别
http和https的区别
手撕SQL：简单查询，表更新，关联查询。建立索引，顺带考察了建立索引的原则，索引失效等
手撕算法：一个1~9组成的字符串，相邻和为10的可消除，求最后长度

### 面经12-一面

https://www.nowcoder.com/feed/main/detail/9cb3fa06f0dc4a7f938a074f34fb0253?sourceSSR=search

1. 三分钟自我介绍
2. 实习项目经历
3. 切换语言的意愿
4. 处理高并发的优化等问题
5. 慢接口优化
6. 怎么开启慢查询的检测
7. 分库分表提升数据库性能的依据
8. Java中的锁升级过程 
9. 锁升级的目的
10. Java当中的单例模式几种写法
11. 不加锁的形式保证单例模式的安全
12. B+树的结构讲解
13.  怎么计算B+树的数据量
14. linux系统中怎么排查故障
15. 有写过网络编程的代码吗
16. Java网络框架底层怎么运行的
17. TCP跟UDP的最大区别
18. 怎么理解拥塞控制
19. 怎么样能够观察到拥塞的发送，从系统以及工具的方面
20. ping的报文在哪一层（网络层）
21. 算法 1.LRU算法 2.亲密字符串
上周五面的，到现在还没有二面，估计凉了。

### 面经13-二面

https://www.nowcoder.com/feed/main/detail/33a9c7ec4c0a474498d231b82866b469?sourceSSR=search

腾讯云智二面 第一次见这么恶心的面试官
上来一副高高在上的样子，从自我介绍开始就不断打断，问八股的时候一直是只想听他的莫名其妙的回答
：tcp三次挥手第一次主要做什么第二次三次是什么，我小林计网八股背了n遍被他整得晕乎乎的。
然后问了一下就开始做题三道题：
最低时间复杂度找众数  LRU 模板类设计模式
然后在问项目，说最难的点，说难点肯定要介绍业务背景吧？他不断打断，真草了这种面试官。
 ，不想面别面!

### 面经14-二面

https://www.nowcoder.com/discuss/604714924840943616?sourceSSR=search

自我介绍

聊家常，问我六级成绩，问我哪里人

让我给他看下简历

算法：求前k个最大的数

智力题：

- 有25匹马和5个赛道，求最快的三匹马，我想了20分钟没想出来，然后他说换道题

  https://blog.csdn.net/realYuzhou/article/details/109024970

- 给你5L和3L的杯子，如何得到4L水

  https://blog.csdn.net/ryyzxf/article/details/112343364

反问：

业务具体内容

什么时候出结果，他说要横向对比一下

### 最长回文子串

### 面经-三面

https://www.nowcoder.com/discuss/609920311651282944?sourceSSR=users

腾讯云智后端暑期实习三面(30min)
面试官自我介绍，我自我介绍
介绍下学校的经历
觉得哪门课学的最好，感觉印象比较深的事
为什么选择这个项目
这个项目你做了哪些改进和思考
讲一下Socket编程
为什么要有select，poll，epoll
除了RocketMQ还知道哪些MQ吗，怎么选择
如何学习技术

- 对云计算了解多少，云计算的优势与劣势

  我对云计算有相当多的了解。云计算是一种通过互联网提供计算服务的模式，用户可以通过云服务提供商按需获取计算资源，如服务器、存储、数据库、网络等，而无需自行建设和维护硬件设施。这种模式下，用户可以根据需求灵活地扩展或缩减资源，按使用量付费，大大降低了IT基础设施的建设和运维成本。

  优势：
  1. 灵活性与可扩展性：云计算允许用户根据需要动态调整计算资源，使其能够适应业务需求的变化，从而提高了灵活性和可扩展性。
  2. 成本效益：采用云计算可以将大量的硬件成本转变为按需付费的操作成本，有利于企业节约资金，并使得中小型企业也能够享受到高性能的计算资源。
  3. 高可用性与容错性：云计算服务商通常会在多个地理位置部署数据中心，以确保服务的高可用性和容错性，从而降低了系统因单点故障而导致的风险。
  4. 自动化管理：云计算平台提供了丰富的自动化管理功能，包括自动备份、自动扩展、自动监控等，减少了运维人员的工作量，提高了系统的稳定性和安全性。
  5. 资源共享与协作：云计算平台可以让用户轻松地共享和协作，使得团队成员可以在不同地点和时间协同工作，提高了工作效率和协作能力。

  劣势：
  1. 安全性：云计算虽然提供了严格的安全措施，但数据在云端存储和传输过程中仍存在被攻击或泄露的风险，尤其是对于一些敏感数据。
  2. 依赖网络：使用云计算需要依赖稳定的网络连接，如果网络出现故障或者延迟，可能会影响到用户的正常使用。
  3. 隐私问题：将数据存储在第三方云服务商的服务器上，可能会引发隐私泄露和合规性问题，尤其是对于一些法律法规要求严格的行业。
  4. 数据锁定：一旦企业将数据存储在某个云服务商的服务器上，可能会面临数据锁定的问题，难以迁移到其他云平台或者私有数据中心。
  5. 性能不稳定：由于云计算服务是多租户的，可能会受到其他用户的影响而导致性能不稳定，特别是在高峰期。

  综合来看，云计算的优势在于灵活性、成本效益和自动化管理等方面，但也需要注意安全性、网络依赖和隐私问题等潜在风险。因此，在采用云计算时，需要根据具体情况综合考虑其优缺点，并采取相应的安全措施和风险管理策略。



### 面经-三面

https://www.nowcoder.com/discuss/607680356929503232?sourceSSR=users

三面就是 HR 面了，暑期实习，可能有的部门还有技术面，大概 2- 3 天会出结果，可能会到下周。

我这边就简单阐述了，不是技术面。

1）自我介绍

2）base 地点

3）学校实习方面

4）绩点

5）考研 or 就业

6）四六级

7）为什么想来？

8）实习经历阐述

9）开源项目

10）项目难点、优化，升级

11）其他 offer？

12）AI 模型看法、使用等等

13）反问面试结果，业务

base 地点是西安，近期有云智面试的小伙伴可以参考一下，我前两期的技术面都写了，然后给了一些回答的思路，可以稍微看看。

### HR面

https://www.nowcoder.com/feed/main/detail/4d627feae612483585ba0d082e8351d8?sourceSSR=search

4.17云智 技术运营 三面 

1.自我介绍

2.介绍岗位的地点

3.关于实习的规划

4.有一段实习期间应该还在校，如何实习的

5.为什么会考虑西安这个平台

6.你有亲戚朋友在西安这边吗

7.你现在找暑期实习是不是也是一个海投的状态
8.你投递的企业有没有一个行业的分类啊？
9.具体为什么会这样考虑呢？为什么会觉得它是一个非常好的发展前景的一个体验呢
10.实习或者是学习中印象深刻的事情
11.追问：之后有没有遇到类似的情况
12.实习期间有哪些收获？
13.如果我们最终达成意向，最早什么时候能到岗
14.你身边玩的好的朋友，他们现在实习的一个状态
