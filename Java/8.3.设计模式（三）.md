## 设计模式（三）

参考：[[掘金](https://juejin.cn/post/7202820042688528445#heading-18)]

### 19.？ 责任链模式（Chain of Responsibility Pattern）

责任链模式是一种行为型设计模式，它允许多个对象来处理请求，并且将这些对象连成一条链。当请求到来时，它会依次经过链上的对象，直到有一个对象能够处理请求为止。

责任链模式和[过滤器模式](https://juejin.cn/post/7199907126688825400#heading-32)都是行为型设计模式，它们的主要目的是将处理请求的对象组织成一个链，并让请求沿着这个链传递，直到找到能够处理该请求的对象为止。

>   那他们有什么区别吗？

1. 用途不同：责任链模式的主要目的是让多个对象都有机会处理同一个请求，而过滤器模式的主要目的是在一个对象中实现多个过滤器，并依次对请求进行处理。
2. 处理方式不同：责任链模式中，每个处理器都会判断自己是否能够处理请求，如果可以则处理请求，并将请求传递给下一个处理器；如果不能处理，则将请求传递给下一个处理器。而过滤器模式中，每个过滤器都是独立的，它们按照一定的顺序依次处理请求，如果某个过滤器不能处理请求，则直接返回。
3. 对象关系不同：责任链模式中，处理器之间通常是单向关系，即每个处理器只知道下一个处理器是谁，而不知道上一个处理器是谁。而过滤器模式中，过滤器之间通常是相互独立的，它们不需要知道彼此的存在。
4. 实现方式不同：责任链模式通常是通过继承或组合的方式实现的，而过滤器模式通常是通过组合的方式实现的。

#### 使用场景

责任链模式通常用于以下场景：

- 请求的处理涉及多个对象，并且处理流程需要按顺序进行。
- 请求的处理方式需要动态决定，或者需要在不同时间处理请求。
- 在请求处理过程中，需要将请求拆分成多个部分分别处理，最后将它们合并。
- 需要在不影响客户端的情况下增强处理流程。
- 需要在系统中动态添加或删除处理器。
- 处理器之间需要解耦，避免它们之间的直接依赖关系。

#### 代码实现

假设我们有一个处理`HTTP`请求的框架，其中有多个过滤器（`Filter`），每个过滤器都可以对请求进行处理，如果当前的过滤器不能处理请求，就将请求交给下一个过滤器。代码如下：

### 20. 解释器模式（Interpreter Pattern）

解释器模式是一种行为型设计模式，它定义了一种语言语法，以及解释器，可以解释这种语法。解释器模式通常用于编译器、解析器、表达式计算器等领域。例如，正则表达式引擎就是一个常见的使用解释器模式的例子。

#### 使用场景

1. 当有一个语言需要解释执行，并且可以将该语言表示为一个抽象语法树时，解释器模式是一个很好的选择。
2. 当需要处理一些规则或配置时，解释器模式也可以作为一种替代方案。例如，编写一个计算器程序时，可以使用解释器模式来处理表达式。
3. 当需要实现一些复杂的规则或策略时，解释器模式也是一种不错的选择。例如，编写一个自然语言处理程序时，可以使用解释器模式来解析和理解语言的语法结构。

#### 代码实现

下面是一个简单的Java解释器模式的例子，用于计算加法表达式的值：

```java
public interface Expression {
    int interpret();
}
```

```java
public class NumberExpression implements Expression {
    private final int number;

    public NumberExpression(int number) {
        this.number = number;
    }

    @Override
    public int interpret() {
        return number;
    }
}
```

```java
public class PlusExpression implements Expression {
    private final Expression leftExpression ;
    private final Expression rightExpression ;

    public PlusExpression(Expression leftExpression, Expression rightExpression) {
        this.leftExpression = leftExpression;
        this.rightExpression = rightExpression;
    }

    @Override
    public int interpret() {
        return leftExpression.interpret() + rightExpression.interpret();
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        Expression expression = new PlusExpression(new NumberExpression(1), new NumberExpression(2));
        System.out.println(expression.interpret());
    }
}
```

这里定义了两种表达式：`NumberExpression`表示一个数字，`PlusExpression`表示加法表达式。`PlusExpression`包含左表达式和右表达式，它们可以是数字或其他表达式。`interpret`方法用于计算表达式的值。

  在实际应用中，解释器模式可能会更加复杂，但这个例子可以帮助我们了解解释器模式的基本思想和实现方式。

#### 使用小结

在`Java`中，解释器模式常常应用于编译器、正则表达式、模板引擎、SQL解析器等方面。常用的`Java`模板引擎，如`FreeMarker和Thymeleaf`等，都是基于解释器模式实现的。

**解释器模式的缺点是**：它可能会导致类的数量增加，并且在解析复杂的语法时，可能会导致性能问题。因此，在选择解释器模式时，需要考虑这些因素。

### 21. 迭代器模式（Iterator Pattern）

迭代器模式是一种行为设计模式，它提供一种统一的方法来遍历一个容器中的所有元素，而不用暴露容器的内部结构。

使用迭代器模式可以将遍历容器和容器本身的实现分离开来，从而可以在不影响容器的情况下更改遍历算法。此外，迭代器模式可以简化遍历代码，并提供更加通用的遍历方法。

#### 使用场景

1. 需要遍历一个容器中的所有元素，但是不想暴露容器的内部结构。
2. 需要提供一个通用的遍历方法，而不需要知道容器的具体实现细节。
3. 需要支持多种不同的遍历方式，例如正序、倒序、随机等。
4. 需要对容器的遍历算法进行更改，但是不想影响容器本身的实现。
5. 需要在遍历过程中同时进行修改操作

#### 代码实现

下面是一个使用`Java`迭代器模式的简单例子，以遍历一个名字列表为例：

首先定义一个名字列表接口，包含两个方法：添加名字和获取迭代器。

然后定义一个名字列表实现类，实现添加名字和获取迭代器的方法。

在这个实现类中，定义了一个内部类 `NameIterator`，实现了 `Iterator` 接口中的 `hasNext、next 和 remove `方法。

```java
public interface NameList {
    void addName(String name);
    Iterator<String> iterator();
}
```

```java
public class NameListImpl implements NameList {
    private List<String> names = new ArrayList<>();

    @Override
    public void addName(String name) {
        names.add(name);
    }

    @Override
    public Iterator<String> iterator() {
        return new NameIterator();
    }

    private class NameIterator implements Iterator<String> {
        private int index = 0;

        @Override
        public boolean hasNext() {
            return index  < names.size();
        }

        @Override
        public String next() {
            return names.get(index ++);
        }

        @Override
        public void remove() {
            names.remove(-- index);
        }
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        NameList nameList = new NameListImpl();
        nameList.addName("Alice");
        nameList.addName("Bob");
        nameList.addName("Charlie");

        Iterator<String> iterator = nameList.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

#### 使用小结

在`Java`中，迭代器模式已经被广泛应用在集合类中。`Java`集合类中都实现了`Iterator`接口，提供了一种通用的迭代器实现方式，可以方便地遍历集合中的所有元素。

### 22. 中介者模式（Mediator Pattern）

中介者模式用于降低多个对象之间的耦合，通过将多个对象之间的通信封装在一个中介者对象中来实现。中介者对象可以独立地管理对象之间的交互，并且可以让这些对象互相通信而不必显示地引用彼此。

#### 使用场景

1. 多个对象之间存在复杂的相互关系，但是它们的交互逻辑比较分散和混乱。
2. 当一个对象需要和其他多个对象进行交互时，如果每个对象都直接和其他对象进行交互，那么会产生复杂的调用关系，导致代码难以维护和扩展。
3. 当一个对象的改变会影响到其他多个对象的状态时，如果每个对象都需要手动处理状态变化，那么也会产生复杂的交互逻辑和调用关系。

#### 代码实现

假设正在开发一个聊天室应用程序，我们可以使用中介者模式来协调多个聊天用户之间的交互。在这个应用程序中，每个聊天用户都可以发送消息给其他用户，而中介者将负责将这些消息传递给其他用户。

具体实现中，我们可以定义一个中介者接口，其中包含一个发送消息的方法。然后我们可以创建一个具体的中介者实现，该实现将负责将消息从一个聊天用户传递到另一个聊天用户。我们还需要创建一个聊天用户接口和具体的聊天用户实现，以便我们可以让多个聊天用户加入到中介者中，并相互交互。

以下是一个简单的 Java 中介者模式示例，其中包含一个中介者接口（`ChatMediator`），聊天用户接口（`ChatUser`）和具体实现（`UserImpl`），以及一个具体的中介者实现（`ChatMediatorImpl`）：

```java
public interface ChatMediator {
    void sendMessage(String msg, ChatUser user);
}
```

```java
// 聊天用户接口
public interface ChatUser {
    void receiveMessage(String msg);
    void sendMessage(String msg);
}
```

```java
public class ChatMediatorImpl implements ChatMediator {
    private List<ChatUser> users;

    public ChatMediatorImpl() {
        this.users = new ArrayList<>();
    }

    @Override
    public void sendMessage(String msg, ChatUser user) {
        for (ChatUser u : users) {
            if (u != user) {  // 广播模式
                u.receiveMessage(msg);
            }
        }
    }

    public void addUser(ChatUser user) {
        users.add(user);
    }
}
```

```java
public class ChatUserImpl implements ChatUser {
    private ChatMediator chatMediator;
    private String name;

    public ChatUserImpl(ChatMediator chatMediator, String name) {
        this.chatMediator = chatMediator;
        this.name = name;
    }

    @Override
    public void receiveMessage(String msg) {
        System.out.println(name + " received " + msg);
    }

    @Override
    public void sendMessage(String msg) {
        chatMediator.sendMessage(msg, this);
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        ChatMediatorImpl mediator = new ChatMediatorImpl();

        ChatUser user1 = new ChatUserImpl(mediator, "lzh1");
        ChatUser user2 = new ChatUserImpl(mediator, "lzh2");
        ChatUser user3 = new ChatUserImpl(mediator, "lzh3");

        mediator.addUser(user1);
        mediator.addUser(user2);
        mediator.addUser(user3);

        user1.sendMessage("我是lzh1");
        user2.sendMessage("我是lzh2");
        user3.sendMessage("我是lzh3");
    }
}
```

输出：

```
lzh2 received 我是lzh1
lzh3 received 我是lzh1
lzh1 received 我是lzh2
lzh3 received 我是lzh2
lzh1 received 我是lzh3
lzh2 received 我是lzh3
```

#### 使用小结

在`MVC`框架中，中介者模式被广泛使用，模型和视图之间的通信和控制都可以通过中介者来实现，降低模块之间的耦合度，提高整个系统的可维护性和可扩展性。

中介者模式将复杂的交互转化为中介者对象和其他对象之间的简单交互，从而使系统易于维护和扩展。

### 23. 备忘录模式（Memento Pattern）

备忘录模式是一种设计模式，它允许在不破坏封装性的情况下保存和恢复对象的状态。这种模式通常用于需要提供撤销或恢复操作的应用程序中。

#### 使用场景

- 需要提供撤销操作的应用程序，例如文本编辑器等。在这种情况下，备忘录模式可以用于保存对象的历史状态，并在需要时恢复对象的状态。
- 需要保存对象状态以进行后续恢复的应用程序。例如，游戏保存和恢复状态。
- 需要在不破坏对象封装性的情况下保存和恢复对象状态的应用程序。
- 需要跟踪和记录对象状态变化的应用程序。例如，监控和记录系统状态变化。

#### 代码实现

假设我们有一个文本编辑器类，需要提供撤销和恢复操作：

```java
public class TextEditor {
    private String text;
    private Stack<TextEditorMemento> undoStack;
    private Stack<TextEditorMemento> redoStack;

    public TextEditor(String text) {
        this.text = text;
        this.undoStack = new Stack<>();
        this.redoStack = new Stack<>();
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        undoStack.push(new TextEditorMemento(this.text));  // 保存之前处理的对象
        this.text = text;
        redoStack.clear();
    }

    public void undo() {
        if (!undoStack.isEmpty()) {
            redoStack.push(new TextEditorMemento(this.text));
            this.text = undoStack.pop().getText();
        }
    }

    public void redo() {
        if (!redoStack.isEmpty()) {
            undoStack.push(new TextEditorMemento(this.text));
            this.text = redoStack.pop().getText();
        }
    }

    private static class TextEditorMemento {
        private String text;

        public TextEditorMemento(String text) {
            this.text = text;
        }

        public String getText() {
            return text;
        }
    }
}
```

`TextEditor`是文本编辑器类，它有一个文本属性`text`，并且有两个栈`undoStack`和`redoStack`，用于保存备忘录。`setText()`方法用于设置文本，并将旧的文本备份到`undoStack`中。`undo()`方法用于撤销操作，从`undoStack`中取出上一个备忘录，并将当前文本备份到`redoStack`中。`redo()`方法用于恢复操作，从`redoStack`中取出上一个备忘录，并将当前文本备份到`undoStack`中

#### 使用小结

通过使用备忘录模式，我们可以轻松地提供撤销和恢复操作，同时保持其封装性和简洁性。如果需要实现多次撤销和恢复操作，我们只需要保存多个备忘录即可。