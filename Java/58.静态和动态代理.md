## 静态代理和动态代理

[https://blog.csdn.net/promsing/article/details/115411648](https://blog.csdn.net/promsing/article/details/115411648)

详细：[https://cloud.tencent.com/developer/article/2149463](https://cloud.tencent.com/developer/article/2149463)

 代理: 就是让代理角色帮助真实角色完成一件事情;

 举例:过年回家让朋友代买火车票，朋友帮你买火车票的过程就是代理

静态代理和动态代理是实现代理模式的两种主要方式，它们在软件开发中用于在访问对象时提供额外的功能，如访问控制、日志记录、延迟初始化等。下面是静态代理和动态代理的概述以及它们之间的区别。

**静态代理**

静态代理是在编译时就已经实现的代理。这意味着代理类在编译前就已经存在，并且是手动编写的。静态代理通常要求代理类和目标对象实现相同的接口或继承相同的类。

- **优点**：
  - 易于理解和实现。
  - 对于简单的代理场景，可以快速地提供解决方案。

- **缺点**：
  - 如果接口增加方法，那么目标对象和其代理类都需要进行修改，不利于维护。
  - 为每个目标类编写一个代理类会导致大量的重复代码。

**动态代理**

动态代理，与静态代理相对，是在程序运行时动态创建的代理。它不需要事先编写代理类的代码，而是在运行时动态地将代理对象与目标对象绑定。Java中的动态代理主要通过`java.lang.reflect.Proxy`类和`InvocationHandler`接口实现。

- **优点**：
  - 动态代理避免了静态代理中的大量重复代码和接口方法变更问题，具有更好的扩展性和灵活性。
  - 可以动态地为多个类生成代理，减少编码工作量和维护成本。

- **缺点**：
  - 实现复杂度高于静态代理。
  - 性能开销相对较大，因为动态代理的实现涉及到反射等机制。

**区别总结**

- **实现时机**：静态代理是编译时实现的，而动态代理是运行时动态生成的。
- **代码复用性**：动态代理比静态代理有更好的复用性和灵活性。
- **性能**：静态代理的性能通常比动态代理要好，因为动态代理的实现需要通过反射等机制，这会增加一定的运行时开销。
- **易用性**：静态代理更简单直接，易于理解；动态代理虽然实现复杂，但能提供更加灵活和强大的代理机制。

选择哪一种代理方式取决于具体的应用场景和对性能、灵活性的要求。、

### 静态代理

 什么是静态代理:

>  静态代理相当于是多写了一个代理类，在调用的时候调用的是代理类，在代理类中的处理还是原生的处理逻辑，不过在前后添加上需要添加的代码。 缺点：需要为每一个被代理的对象都创建一个代理类。 

 特点:

>   代理角色和真实角色都需要实现同一个接口,  真实角色专注于自己的事情,  代理角色目的就是帮助真实角色完成一件事情  多线程的实现方式2:实现一个接口Runnable 使用的就是”静态代理”的思想 

静态代理代码：

```java
package com.example.juc.proxy;

/**
 * @author mkid
 * @version 1.0
 * @description 静态代理
 * @date 2024/4/22 22:34
 */

interface Mary {
    void mary();
}

class You implements Mary {
    @Override
    public void mary() {
        System.out.println("要结婚了，很开心");
    }
}

class Company implements Mary {
    private Mary mary;

    public Company(Mary mary) {
        this.mary = mary;
    }

    @Override
    public void mary() {
        System.out.println("婚前方法");
        mary.mary();
        System.out.println("婚后方法");
    }
}

public class StaticProxy {

    public static void main(String[] args) {
        Mary mary = new You();
        mary.mary();
        System.out.println("------------------------");
        // 使用静态代理
        You you = new You();
        Company company = new Company(you);
        company.mary();
    }

}
```

使用接口 `Runnable` 实现多线程的方式之一是通过创建一个类来实现 `Runnable` 接口，并在该类中实现 `run()` 方法，然后使用该类的实例创建线程对象。关于“静态代理”的思想，可以在实现 `Runnable` 接口的类中创建一个新的类，该类实现 `Runnable` 接口，并在其 `run()` 方法中调用原始 `Runnable` 实例的 `run()` 方法，这就是静态代理的概念。这样做的好处是可以在调用原始 `run()` 方法之前或之后执行一些额外的操作。

下面是一个示例代码：

```java
// 原始的实现了 Runnable 接口的类
class OriginalTask implements Runnable {
    @Override
    public void run() {
        System.out.println("Executing original task...");
    }
}

// 代理类
class ProxyTask implements Runnable {
    private Runnable originalTask;

    public ProxyTask(Runnable originalTask) {
        this.originalTask = originalTask;
    }

    @Override
    public void run() {
        System.out.println("Before executing original task...");
        originalTask.run(); // 调用原始任务的 run 方法
        System.out.println("After executing original task...");
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建原始任务实例
        OriginalTask originalTask = new OriginalTask();
        
        // 创建代理任务实例，将原始任务实例传入
        ProxyTask proxyTask = new ProxyTask(originalTask);
        
        // 使用代理任务创建线程
        Thread thread = new Thread(proxyTask);
        
        // 启动线程
        thread.start();
    }
}
```

这段代码中，`OriginalTask` 是原始的实现了 `Runnable` 接口的类，`ProxyTask` 是代理类，它实现了 `Runnable` 接口，并在 `run()` 方法中调用了原始任务的 `run()` 方法，在调用前后添加了额外的操作。在 `Main` 类中创建了原始任务的实例和代理任务的实例，然后使用代理任务创建了线程，并启动了线程。

### 动态代理

什么是动态代理?

>  Java标准库提供了动态代理功能，**允许在运行期动态创建一个接口的实例**； 动态代理是通过 Proxy 创建代理对象，然后将接口方法“代理”给 InvocationHandler 完成的。

动态代理代码：

```java
package com.example.juc.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @author mkid
 * @version 1.0
 * @description 动态代理，通过反射，在运行时创建
 * @date 2024/4/22 22:57
 */

interface Hello {
    void sayHello();
}

class HelloImpl implements Hello {
    @Override
    public void sayHello() {
        System.out.println("hello");
    }
}

// Invocation实现类
class MyInvocationHandler implements InvocationHandler {

    private Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 在调用目标方法之前可以添加一些额外的逻辑
        System.out.println("Before calling method: " + method.getName());
        // 调用目标方法
        Object result = method.invoke(target, args);
        // 在调用方法之后可以添加一些额外的逻辑
        System.out.println("After calling method: " +method.getName());
        return result;
    }
}

public class DynamicProxy {

    public static void main(String[] args) {
        // 创建目标对象
        Hello hello = new HelloImpl();
        // 创建InvocationHandler实例
        MyInvocationHandler myInvocationHandler = new MyInvocationHandler(hello);
        // 创建代理对象
        Hello proxyHello = (Hello) Proxy.newProxyInstance(
                hello.getClass().getClassLoader(),
                hello.getClass().getInterfaces(),
                myInvocationHandler
        );
        // 调用代理对象的方法
        proxyHello.sayHello();
    }
}
```

### InvocationHandler接口

`InvocationHandler` 是 Java 中的一个接口，用于实现动态代理。它包含了一个方法 `invoke(Object proxy, Method method, Object[] args)`，在动态代理对象的方法被调用时会被调用。当代理对象的方法被调用时，`invoke()` 方法会接收到代理对象本身、被调用的方法以及方法的参数，并且可以在这个方法中实现一些额外的逻辑，比如在调用被代理对象的方法之前或之后执行一些操作。

动态代理通常使用 `java.lang.reflect.Proxy` 类来创建代理对象，并且需要传入一个实现了 `InvocationHandler` 接口的对象。在代理对象的方法被调用时，`InvocationHandler` 的 `invoke()` 方法会被调用，并且可以在这个方法中实现代理对象的行为。

下面是一个简单的示例代码，演示了如何使用 `InvocationHandler` 创建动态代理：

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 接口
interface Hello {
    void sayHello();
}

// 实现类
class HelloImpl implements Hello {
    @Override
    public void sayHello() {
        System.out.println("Hello, world!");
    }
}

// InvocationHandler 实现类
class MyInvocationHandler implements InvocationHandler {
    private Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 在调用目标方法之前可以添加一些额外的逻辑
        System.out.println("Before calling method: " + method.getName());
        // 调用目标方法
        Object result = method.invoke(target, args);
        // 在调用目标方法之后可以添加一些额外的逻辑
        System.out.println("After calling method: " + method.getName());
        return result;
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建目标对象
        Hello hello = new HelloImpl();

        // 创建 InvocationHandler 实例
        MyInvocationHandler handler = new MyInvocationHandler(hello);

        // 创建代理对象
        Hello proxyHello = (Hello) Proxy.newProxyInstance(
                hello.getClass().getClassLoader(),
                hello.getClass().getInterfaces(),
                handler);

        // 调用代理对象的方法
        proxyHello.sayHello();
    }
}
```

在这个例子中，`Hello` 是一个接口，`HelloImpl` 是实现了 `Hello` 接口的类。`MyInvocationHandler` 实现了 `InvocationHandler` 接口，用于在代理对象的方法被调用时添加额外的逻辑。在 `Main` 类中，创建了目标对象 `hello` 和 `MyInvocationHandler` 的实例 `handler`，然后使用 `Proxy.newProxyInstance()` 方法创建了代理对象 `proxyHello`。当调用代理对象的 `sayHello()` 方法时，实际上会调用 `MyInvocationHandler` 的 `invoke()` 方法，并在其中添加了额外的逻辑。

### 总结

  **静态代理总结：**
 1）代理类的信息在jvm运⾏之前就已经⽣成，逻辑由开发者实现；
 2）代理类与⽬标类的定义应该严格参照规范，定义公共接⼝并实现它，需要代理的⽅法在接⼝中都要定义好；
 静态代理原理：在代理类中包含⼀个⽬标类的对象引⽤，然后在使⽤时创建⼀个⽬标类对象并且创建⼀个代理类对象，并把⽬标类对象传给代
 理类对象，然后将它赋予代理类中的⽬标类对象引⽤，然后代理类所代理的⽅法中通过其所包含的⽬标类对象引⽤调⽤⽬标类的⽅法，从⽽实现通过代理调⽤⽬标类⽅法的效果。

  **动态代理总结：**
 1） 动态代理是指 在java程序运⾏过程（程序已经启动在运⾏了）由jvm⽣成代理类的class信息，该class信息⽣成后是直接处于内存中的，并没有写⼊磁盘保存起来；然后通过反射⽅式实例化代理类对象，因为代理类的class信息已经存在于内存中，所以可以通过反射⽅式实例化。
 这个应该怎么理解呢？
  可以跟上⾯讲过的静态代理对⽐下，静态代理是需要开发⼈员⾃⼰实现代理类的逻辑的，且代理类的class信息是在程序运⾏之前就已经可以获取到的.java⽂件经过编译后可以得到.class⽂件；
  ⽽动态代理是不需要开发⼈员⾃⼰实现代理类的，也就是说使⽤动态代理⽅式的话，项⽬代码中是不存在代理类的.java⽂件的，既然代理类未由开发者实现，那么程序经过编译之后肯定也不会有代理类的.class⽂件，
  也就是说经过编译之后程序未启动运⾏之前，关于代理类的信息我们⼀⽆所知，它是在程序运⾏过程中需要⽤到的时候才会由jvm动态⽣成的，⽽且⽣成之后也只存在于内存中，不会写到磁盘保存成.class⽂件，更加不会保存为.java⽂件；
  在程序重启或者说发⽣了gc，这个代理类的class信息从内存中被卸载之后，关于这个代理类的信息就没有了，只有当代码再次访问到代理对象时，才⼜会重新⽣成代理类的class信息。
 2）动态代理与静态代理的区别是什么？
  上⾯已经讲述，不再赘述。
 3）为什么需要引⼊动态代理？
  这就不得不说到静态代理的弊端，我们引⼊新事物，必定是因为旧事物存在不合理之处，所以才引⼊新的事物来弥补它的缺陷。
  那静态代理有什么缺陷呢？
  我们知道静态代理是需要开发者⾃⼰实现代理类逻辑的，也就是说要对某个类进⾏代理的话，需要实现这个类相应的代理类；
  如果⽬标类的数量很多的话，代理类的实现也必然得很多，可能会造成代码量过于庞⼤，可能会增加代码的冗余度…
  再者，如果⽬标类需要代理的⽅法很多的话，代理类需要对这些⽅法⼀⼀实现代理逻辑，代理类的实现也将会很庞⼤。
 考虑到这些问题，催⽣了动态代理这种⽅式，它相⽐于静态代理来说，由于不需要开发者⾃⼰再实现代理类了，所以在实际⼤型项⽬中可能代码量会⼤⼤减少。

