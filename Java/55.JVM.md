## JVM

### 静态代理和动态代理

静态代理和动态代理是实现代理模式的两种主要方式，它们在软件开发中用于在访问对象时提供额外的功能，如访问控制、日志记录、延迟初始化等。下面是静态代理和动态代理的概述以及它们之间的区别。

#### 静态代理

静态代理是在编译时就已经实现的代理。这意味着代理类在编译前就已经存在，并且是手动编写的。静态代理通常要求代理类和目标对象实现相同的接口或继承相同的类。

- **优点**：
  - 易于理解和实现。
  - 对于简单的代理场景，可以快速地提供解决方案。

- **缺点**：
  - 如果接口增加方法，那么目标对象和其代理类都需要进行修改，不利于维护。
  - 为每个目标类编写一个代理类会导致大量的重复代码。

#### 动态代理

动态代理，与静态代理相对，是在程序运行时动态创建的代理。它不需要事先编写代理类的代码，而是在运行时动态地将代理对象与目标对象绑定。Java中的动态代理主要通过`java.lang.reflect.Proxy`类和`InvocationHandler`接口实现。

- **优点**：
  - 动态代理避免了静态代理中的大量重复代码和接口方法变更问题，具有更好的扩展性和灵活性。
  - 可以动态地为多个类生成代理，减少编码工作量和维护成本。

- **缺点**：
  - 实现复杂度高于静态代理。
  - 性能开销相对较大，因为动态代理的实现涉及到反射等机制。

#### 区别总结

- **实现时机**：静态代理是编译时实现的，而动态代理是运行时动态生成的。
- **代码复用性**：动态代理比静态代理有更好的复用性和灵活性。
- **性能**：静态代理的性能通常比动态代理要好，因为动态代理的实现需要通过反射等机制，这会增加一定的运行时开销。
- **易用性**：静态代理更简单直接，易于理解；动态代理虽然实现复杂，但能提供更加灵活和强大的代理机制。

选择哪一种代理方式取决于具体的应用场景和对性能、灵活性的要求。

### 方法区

在Java中，方法区（Method Area）是一种特殊的内存区域，用于存储类信息、常量、静态变量、即时编译器编译后的代码等。它是Java虚拟机规范中定义的一部分，属于线程共享的内存区域，每个JVM进程只有一个方法区。

方法区主要包括以下内容：

1. 类信息：存储每个类的完整结构，包括类的名称、父类的名称、类的方法、字段、访问控制权限等信息。
2. 常量池（Constant Pool）：存储类文件中的各种字面量和符号引用，包括字符串、类名、方法名、字段名等。
3. 静态变量：存储类的静态成员变量。
4. 即时编译器（Just-In-Time Compiler，JIT Compiler）编译后的代码。
5. 常量：存储在类文件中的静态final常量。

方法区在Java 8及之前的版本中实现为永久代（Permanent Generation），但在Java 8中被元数据区（Metaspace）所取代。元数据区的实现与永久代不同，它是直接使用本地内存来存储方法区的数据，因此避免了永久代的一些限制和问题。

### 四种引用类型

在 Java 中，引用类型用于引用对象而不是直接存储对象的实际数据。Java 中的引用类型包括以下几种：

1. **强引用（Strong Reference）**：
   - 强引用是最常见的引用类型，当我们使用 `new` 关键字创建一个对象时，默认情况下就会得到一个强引用。
   - 只要存在强引用指向一个对象，该对象就不会被垃圾回收器回收。

2. **软引用（Soft Reference）**：
   - 软引用允许在系统内存不足时被回收，但是只有在垃圾回收器确定内存不足时才会回收软引用。
   - 在 Java 中可以使用 `java.lang.ref.SoftReference` 类来创建软引用。

3. **弱引用（Weak Reference）**：
   - 弱引用是比软引用更弱的引用类型，在任何时候都可能被垃圾回收器回收。
   - 弱引用通常用于解决内存泄漏问题，比如对象缓存中，将对象的引用设置为弱引用，当对象没有被强引用持有时，就可以被垃圾回收。
   - 在 Java 中可以使用 `java.lang.ref.WeakReference` 类来创建弱引用。

4. **虚引用（Phantom Reference）**：
   - 虚引用是最弱的一种引用类型，它在任何时候都可能被垃圾回收器回收。
   - 虚引用主要用于跟踪对象被垃圾回收的情况，当虚引用关联的对象被垃圾回收器回收时，虚引用会被放入一个 ReferenceQueue 中，通知应用程序对象已经被回收。
   - 在 Java 中可以使用 `java.lang.ref.PhantomReference` 类来创建虚引用。

这些引用类型在 Java 中提供了不同程度的对象引用控制和内存管理功能，开发人员可以根据具体的需求选择合适的引用类型。

### volatile

https://blog.csdn.net/u012723673/article/details/80682208

单例模式的双重锁检查模式：

```java
public class TestInstance{
  private volatile static TestInstance instance;
  public static TestInstance getInstance(){   //1
    if(instance == null){   //2
      synchronized(TestInstance.class){   //3
        if(instance == null){   //4
          instance = new TestInstance(); //5
        }
      }
    }
    return instance;   //6
  }
}
```

new TestInstance的过程：

```c
a. memory = allocate() //分配内存
b. ctorInstanc(memory) //初始化对象
c. instance = memory   //设置instance指向刚分配的地址
```

![image-20240416192425341](./pic/image-20240416192425341.png)
