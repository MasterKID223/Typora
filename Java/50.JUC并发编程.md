## 并发与多线程

### 线程安全

#### Object的wait和notify方法是什么

在Java中，`Object`类提供了`wait()`和`notify()`方法，这些方法用于实现线程间的协作和同步。

1. `wait()`方法：
   - `wait()`方法用于让当前线程进入等待状态，直到其他线程调用了该对象的`notify()`或`notifyAll()`方法，或者指定的等待时间到期。
   - 当一个线程调用了`wait()`方法后，它会释放对象的锁（即使它是在同步块中调用的）并进入等待状态，直到其他线程通过调用`notify()`或`notifyAll()`来唤醒它，或者等待时间到期。
   - 如果`wait()`方法不带参数，那么线程将一直等待，直到其他线程调用了`notify()`或`notifyAll()`方法来唤醒它。
   - 如果`wait(long timeout)`方法带有超时参数，线程将在指定的时间内等待，如果超时时间到了，它将被唤醒。

2. `notify()`方法：
   - `notify()`方法用于唤醒正在等待该对象锁的线程中的一个线程，具体是哪一个线程取决于调度器。
   - 如果有多个线程在等待，那么只有一个线程会被唤醒，其他线程仍然处于等待状态。
   - 如果没有线程在等待，`notify()`方法不会产生任何作用。

3. `notifyAll()`方法：
   - `notifyAll()`方法用于唤醒所有正在等待该对象锁的线程。
   - 如果有多个线程在等待，它们都会被唤醒。
   - 如果没有线程在等待，`notifyAll()`方法不会产生任何作用。

这些方法通常用于多线程编程中的同步和协作，以确保线程间的正确通信和资源共享。

#### CAS

CAS 是 Compare and Swap 的缩写，中文翻译为比较并交换。在 Java 并发编程中，CAS 是一种乐观锁定机制，用于实现非阻塞算法。它主要由以下三个操作组成：

1. **比较 (Compare)**：CAS 首先比较当前内存中某个位置的值与预期的值是否相等。

2. **交换 (Swap)**：如果相等，则将该位置的值替换为新的值；如果不相等，则不进行任何操作。

3. **更新 (Update)**：CAS 操作是原子的，因此只有在比较相等且替换值的过程中才会更新。

CAS 的基本原理是，如果当前内存值与预期值相等，则将新值替换进去；如果不相等，则表示该位置已经被其他线程修改过，CAS 操作失败。由于 CAS 操作是原子性的，因此可以在多线程环境中确保共享变量的线程安全性，而不需要使用显式的锁。

在 Java 中，CAS 操作由 `java.util.concurrent.atomic` 包下的原子类来实现，例如 `AtomicInteger`、`AtomicLong` 等。这些原子类提供了 CAS 操作的实现，允许开发者在并发环境中安全地执行一些基本的原子操作，而无需使用显式的锁定。CAS 操作的性能通常比传统的锁定机制更高，因为它避免了线程阻塞和上下文切换的开销。

### JUC种的锁

#### 偏向锁、乐观锁

偏向锁（Biased Locking）和乐观锁（Optimistic Locking）是在并发编程中常用的两种锁机制。

1. **偏向锁**：偏向锁是为了解决在没有竞争的情况下，对于同步块的加锁和解锁的性能开销。当一个线程访问同步块并获取锁时，会在对象头上的标记位上记录该线程偏向于这个锁。之后，该线程再次进入同步块时，不需要进行同步操作，直接可以访问，从而提高了性能。但是如果其他线程尝试获取这个锁，则会撤销偏向锁，转换为常规的锁竞争模式。

2. **乐观锁**：乐观锁假设冲突的概率较低，因此允许多个线程同时访问数据，但在更新数据时进行检查以确保没有其他线程已经修改了该数据。通常使用版本号或时间戳等机制来实现。如果检测到数据被其他线程修改，就会进行回滚或者重新尝试。

总的来说，偏向锁适用于热点数据，假设同一线程会多次获得锁的情况；而乐观锁适用于冲突少，读操作多的情况，可以提高并发性能。

### LinkedBlockingQueue与ConcurrentLinkedQueue的区别

参考：[[csdn](https://blog.csdn.net/lzxlfly/article/details/86710382)]

### synchronized

修饰代码块、方法、类等。

### CAS

https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html#cas-%E7%AE%97%E6%B3%95

### 线程状态

当谈到Java中线程状态的实现时，主要涉及到线程调度器、线程对象的状态属性以及对应状态的转换方法。

1. **新建状态（New）**：
   - 当创建一个Thread对象时，线程处于新建状态。此时线程尚未启动，还没有分配到CPU时间片。

2. **就绪状态（Runnable）**：
   - 一旦调用了线程对象的 `start()` 方法，线程就会进入就绪状态。此时，线程已经被加入到线程调度器的就绪队列中，等待获取CPU时间片以执行任务。

3. **运行状态（Running）**：
   - 线程调度器从就绪队列中选中一个线程，分配CPU时间片给它，线程开始执行任务，此时线程处于运行状态。

4. **阻塞状态（Blocked）**：
   - 当线程因为某些原因（如等待I/O操作、等待锁、等待其他线程完成等）而暂时无法继续执行时，线程会进入阻塞状态。在这种状态下，线程不会消耗CPU时间，直到阻塞条件解除。

5. **等待状态（Waiting）**：
   - 线程进入等待状态，是因为调用了 `wait()` 方法，使得线程等待在某个对象上。在等待状态下，线程会释放掉持有的锁，并进入对象的等待队列，直到其他线程调用了相应对象的 `notify()` 或 `notifyAll()` 方法来唤醒该线程。

6. **超时等待状态（Timed Waiting）**：
   - 类似于等待状态，但在等待一定时间后会自动恢复。这个状态可以通过调用 `Thread.sleep()`、`Object.wait(long timeout)`、`Thread.join(long millis)` 或 `LockSupport.parkNanos()` 等方法产生。

7. **终止状态（Terminated）**：
   - 当线程的 `run()` 方法执行完毕，或者因为异常而退出时，线程进入终止状态。

Java通过`Thread`类和`Object`类提供了一系列方法来实现线程状态的控制和管理，例如：
- `Thread.sleep()`：使线程进入睡眠状态。
- `Object.wait()`、`Object.notify()`、`Object.notifyAll()`：实现线程的等待和唤醒机制。
- `Thread.join()`：使当前线程等待指定线程终止。
- `Thread.yield()`：提示线程调度器当前线程愿意放弃CPU执行权。
- `Thread.interrupt()`：中断线程。

通过这些方法，可以对线程的状态进行灵活控制，实现多线程编程中的同步、互斥、等待等功能。

