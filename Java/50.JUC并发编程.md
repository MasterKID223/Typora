## 并发与多线程

### 线程安全

#### Object的wait和notify方法是什么

在Java中，`Object`类提供了`wait()`和`notify()`方法，这些方法用于实现线程间的协作和同步。

1. `wait()`方法：
   - `wait()`方法用于让当前线程进入等待状态，直到其他线程调用了该对象的`notify()`或`notifyAll()`方法，或者指定的等待时间到期。
   - 当一个线程调用了`wait()`方法后，它会释放对象的锁（即使它是在同步块中调用的）并进入等待状态，直到其他线程通过调用`notify()`或`notifyAll()`来唤醒它，或者等待时间到期。
   - 如果`wait()`方法不带参数，那么线程将一直等待，直到其他线程调用了`notify()`或`notifyAll()`方法来唤醒它。
   - 如果`wait(long timeout)`方法带有超时参数，线程将在指定的时间内等待，如果超时时间到了，它将被唤醒。

2. `notify()`方法：
   - `notify()`方法用于唤醒正在等待该对象锁的线程中的一个线程，具体是哪一个线程取决于调度器。
   - 如果有多个线程在等待，那么只有一个线程会被唤醒，其他线程仍然处于等待状态。
   - 如果没有线程在等待，`notify()`方法不会产生任何作用。

3. `notifyAll()`方法：
   - `notifyAll()`方法用于唤醒所有正在等待该对象锁的线程。
   - 如果有多个线程在等待，它们都会被唤醒。
   - 如果没有线程在等待，`notifyAll()`方法不会产生任何作用。

这些方法通常用于多线程编程中的同步和协作，以确保线程间的正确通信和资源共享。

#### CAS

CAS 是 Compare and Swap 的缩写，中文翻译为比较并交换。在 Java 并发编程中，CAS 是一种乐观锁定机制，用于实现非阻塞算法。它主要由以下三个操作组成：

1. **比较 (Compare)**：CAS 首先比较当前内存中某个位置的值与预期的值是否相等。

2. **交换 (Swap)**：如果相等，则将该位置的值替换为新的值；如果不相等，则不进行任何操作。

3. **更新 (Update)**：CAS 操作是原子的，因此只有在比较相等且替换值的过程中才会更新。

CAS 的基本原理是，如果当前内存值与预期值相等，则将新值替换进去；如果不相等，则表示该位置已经被其他线程修改过，CAS 操作失败。由于 CAS 操作是原子性的，因此可以在多线程环境中确保共享变量的线程安全性，而不需要使用显式的锁。

在 Java 中，CAS 操作由 `java.util.concurrent.atomic` 包下的原子类来实现，例如 `AtomicInteger`、`AtomicLong` 等。这些原子类提供了 CAS 操作的实现，允许开发者在并发环境中安全地执行一些基本的原子操作，而无需使用显式的锁定。CAS 操作的性能通常比传统的锁定机制更高，因为它避免了线程阻塞和上下文切换的开销。

### JUC种的锁

#### 偏向锁、乐观锁

偏向锁（Biased Locking）和乐观锁（Optimistic Locking）是在并发编程中常用的两种锁机制。

1. **偏向锁**：偏向锁是为了解决在没有竞争的情况下，对于同步块的加锁和解锁的性能开销。当一个线程访问同步块并获取锁时，会在对象头上的标记位上记录该线程偏向于这个锁。之后，该线程再次进入同步块时，不需要进行同步操作，直接可以访问，从而提高了性能。但是如果其他线程尝试获取这个锁，则会撤销偏向锁，转换为常规的锁竞争模式。

2. **乐观锁**：乐观锁假设冲突的概率较低，因此允许多个线程同时访问数据，但在更新数据时进行检查以确保没有其他线程已经修改了该数据。通常使用版本号或时间戳等机制来实现。如果检测到数据被其他线程修改，就会进行回滚或者重新尝试。

总的来说，偏向锁适用于热点数据，假设同一线程会多次获得锁的情况；而乐观锁适用于冲突少，读操作多的情况，可以提高并发性能。

### LinkedBlockingQueue与ConcurrentLinkedQueue的区别

参考：[[csdn](https://blog.csdn.net/lzxlfly/article/details/86710382)]

### synchronized

修饰代码块、方法、类等。

### CAS

https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html#cas-%E7%AE%97%E6%B3%95

### 线程状态

当谈到Java中线程状态的实现时，主要涉及到线程调度器、线程对象的状态属性以及对应状态的转换方法。

1. **新建状态（New）**：
   - 当创建一个Thread对象时，线程处于新建状态。此时线程尚未启动，还没有分配到CPU时间片。

2. **就绪状态（Runnable）**：
   - 一旦调用了线程对象的 `start()` 方法，线程就会进入就绪状态。此时，线程已经被加入到线程调度器的就绪队列中，等待获取CPU时间片以执行任务。

3. **运行状态（Running）**：
   - 线程调度器从就绪队列中选中一个线程，分配CPU时间片给它，线程开始执行任务，此时线程处于运行状态。

4. **阻塞状态（Blocked）**：
   - 当线程因为某些原因（如等待I/O操作、等待锁、等待其他线程完成等）而暂时无法继续执行时，线程会进入阻塞状态。在这种状态下，线程不会消耗CPU时间，直到阻塞条件解除。

5. **等待状态（Waiting）**：
   - 线程进入等待状态，是因为调用了 `wait()` 方法，使得线程等待在某个对象上。在等待状态下，线程会释放掉持有的锁，并进入对象的等待队列，直到其他线程调用了相应对象的 `notify()` 或 `notifyAll()` 方法来唤醒该线程。

6. **超时等待状态（Timed Waiting）**：
   - 类似于等待状态，但在等待一定时间后会自动恢复。这个状态可以通过调用 `Thread.sleep()`、`Object.wait(long timeout)`、`Thread.join(long millis)` 或 `LockSupport.parkNanos()` 等方法产生。

7. **终止状态（Terminated）**：
   - 当线程的 `run()` 方法执行完毕，或者因为异常而退出时，线程进入终止状态。

Java通过`Thread`类和`Object`类提供了一系列方法来实现线程状态的控制和管理，例如：
- `Thread.sleep()`：使线程进入睡眠状态。
- `Object.wait()`、`Object.notify()`、`Object.notifyAll()`：实现线程的等待和唤醒机制。
- `Thread.join()`：使当前线程等待指定线程终止。
- `Thread.yield()`：提示线程调度器当前线程愿意放弃CPU执行权。
- `Thread.interrupt()`：中断线程。

通过这些方法，可以对线程的状态进行灵活控制，实现多线程编程中的同步、互斥、等待等功能。



### Runnable和Callable异常

`Runnable` 接口本身并不支持抛出检查型异常（checked exception），它的 `run` 方法签名如下：

```java
public interface Runnable {
    public abstract void run();
}
```

`run` 方法可以抛出未检查型异常（unchecked exception），也就是运行时异常（如 `NullPointerException`, `IllegalArgumentException` 等）和错误（如 `Error` 子类）。

如果你需要在 `Runnable` 的 `run` 方法中处理一些可能抛出检查型异常的操作，那么你有几种选择：

1. **捕获并处理异常**：在 `run` 方法内部捕获异常，并且妥善处理它。例如记录日志或者做一些清理工作。

   ```java
   public class MyRunnable implements Runnable {
       @Override
       public void run() {
           try {
               // 可能抛出检查型异常的操作
               doSomethingThatThrowsCheckedException();
           } catch (SomeCheckedException e) {
               // 异常处理逻辑
               System.err.println("Caught checked exception: " + e.getMessage());
           }
       }
   }
   ```

2. **转换成运行时异常**：如果希望上层调用者也能感知到异常的发生，可以将检查型异常转换为运行时异常。

   ```java
   public class MyRunnable implements Runnable {
       @Override
       public void run() {
           try {
               doSomethingThatThrowsCheckedException();
           } catch (SomeCheckedException e) {
               throw new RuntimeException(e);
           }
       }
   }
   ```

3. **使用 Future 和 Callable**：如果你是在使用 `ExecutorService` 并且希望处理任务执行后的结果以及可能发生的异常，可以考虑使用 `Callable<V>` 接口替代 `Runnable`，并通过 `Future<V>` 获取结果。`Callable` 的 `call` 方法可以抛出检查型异常，并且这些异常会被 `Future.get()` 方法抛出。

   ```java
   ExecutorService executor = Executors.newSingleThreadExecutor();
   Future<String> future = executor.submit(new MyCallable());
   try {
       String result = future.get(); // 可以抛出 ExecutionException, InterruptedException
   } catch (ExecutionException e) {
       e.getCause().printStackTrace();
   } catch (InterruptedException e) {
       Thread.currentThread().interrupt(); // 恢复中断状态
   } finally {
       executor.shutdownNow();
   }
   ```

在这个例子中，`MyCallable` 实现了 `Callable<String>` 接口，并且其 `call` 方法可以抛出检查型异常。这些异常会被封装进 `ExecutionException` 中，当调用 `future.get()` 时可以被捕获。



### LockSupport

`LockSupport` 是 Java 并发工具包（`java.util.concurrent` 包）中的一个类，用于帮助实现线程间的同步和阻塞。它提供了一些静态方法来帮助管理线程的状态，特别是用于构建锁和其他同步工具的基础。

**主要方法**

`LockSupport` 提供了几种主要的方法来控制线程的暂停（parking）和唤醒（unparking）：

- **`park()`**：使当前线程进入等待状态。如果当前线程被中断，那么这个方法会抛出 `InterruptedException`。
- **`parkNanos(long nanos)`** 和 **`parkUntil(long deadline)`**：与 `park()` 类似，但是可以指定一个等待的时间期限。
- **`unpark(Thread thread)`**：解除对特定线程的阻塞状态。如果目标线程已经被 unpark 或者已经终止，那么这个调用不会产生任何效果。

**使用示例**

下面是一个简单的示例，展示如何使用 `LockSupport` 来控制两个线程之间的同步：

```java
import java.util.concurrent.locks.LockSupport;

public class LockSupportExample {

    public static void main(String[] args) {
        Thread producer = new Thread(() -> {
            System.out.println("Producer is running...");
            // 让生产者线程暂停
            LockSupport.park();
            System.out.println("Producer was unparked.");
        });

        Thread consumer = new Thread(() -> {
            try {
                Thread.sleep(1000); // 模拟一些工作
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 唤醒生产者线程
            LockSupport.unpark(producer);
            System.out.println("Consumer unparked the producer.");
        });

        producer.start();
        consumer.start();
    }
}
```

在这个例子中，生产者线程在开始后会立即调用 `LockSupport.park()` 来阻塞自己，直到消费者线程调用 `LockSupport.unpark(producer)` 唤醒它。

**常见用途**

- **线程间通信**：`LockSupport` 可以用来实现线程间的简单信号量机制，例如一个线程等待另一个线程完成某项工作。
- **线程池中的工作窃取模式**：在某些线程池实现中，当一个线程没有任务可做时，它可以调用 `park()` 来节省资源，直到有新任务可用。
- **构建自定义同步组件**：由于 `LockSupport` 提供了底层的线程阻塞和唤醒机制，因此可以用来构建更复杂的同步结构，如 `Semaphore` 或 `CountDownLatch`。

**注意事项**

- `LockSupport` 的 `park` 方法会导致当前线程挂起，因此应该在适当的时机调用 `unpark` 方法来避免线程永久挂起。
- `LockSupport` 的使用需要谨慎，因为不当的使用可能会导致死锁或资源泄露等问题。
- `LockSupport` 的 `unpark` 方法可以被多次调用，但是 `park` 方法只需要一次就可以唤醒线程。因此，在设计同步逻辑时需要注意这一点。



### 线程的interrupt状态

在 Java 中，停止一个线程并不是一件简单的事情，因为直接终止线程可能会导致资源泄露、数据不一致等问题。因此，Java 不推荐使用 `Thread.stop()` 方法来终止线程，因为它已经被标记为已废弃（deprecated），并且在未来的版本中可能会被移除。

以下是几种安全地停止线程的方法：

**1. 标志位（Flag Variable）**

最常用的方法是使用一个共享的标志位来控制线程的运行。当外部想要停止线程时，可以修改这个标志位，线程在每次循环中都会检查这个标志位，决定是否继续执行。

```java
public class StoppableThread extends Thread {
    private volatile boolean keepRunning = true;

    @Override
    public void run() {
        while (keepRunning) {
            // 执行任务
            System.out.println("线程正在运行...");

            // 模拟耗时操作
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // 如果线程被中断，退出循环
                keepRunning = false;
                Thread.currentThread().interrupt(); // 恢复中断状态
            }
        }
        System.out.println("线程停止了");
    }

    public void stopThread() {
        keepRunning = false;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        StoppableThread thread = new StoppableThread();
        thread.start();

        // 让线程运行一段时间后停止
        Thread.sleep(5000); // 等待5秒
        thread.stopThread();
    }
}
```

**2. 中断（Interrupt）**

另一种方法是通过中断线程来通知它停止。当线程被中断时，它应该检查中断状态，并采取相应的措施来结束自己。

```java
public class InterruptableThread extends Thread {
    @Override
    public void run() {
        while (!Thread.currentThread().isInterrupted()) {
            // 执行任务
            System.out.println("线程正在运行...");

            // 模拟耗时操作
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // 如果线程被中断，退出循环
                System.out.println("线程被中断了");
                Thread.currentThread().interrupt(); // 恢复中断状态
                return; // 结束线程
            }
        }
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        InterruptableThread thread = new InterruptableThread();
        thread.start();

        // 让线程运行一段时间后中断
        Thread.sleep(5000); // 等待5秒
        thread.interrupt(); // 中断线程
    }
}
```

**注意事项**

- 使用标志位或中断机制时，一定要保证线程在正常情况下能够响应标志位或中断信号。如果线程陷入了长时间的阻塞状态（如 I/O 阻塞），那么它可能无法及时响应中断信号。
- 在使用中断时，记得处理 `InterruptedException` 并恢复中断状态，以便更高层次的代码能够检测到中断。
- 不要依赖于 `Thread.stop()` 或 `Thread.suspend()` 等方法，因为它们已经被弃用，并且它们可能导致数据不一致和其他问题。



### Object头

https://developer.aliyun.com/article/1232922

![image-20240910001319074](./pic/image-20240910001319074.png)
