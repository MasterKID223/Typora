## 多线程

### ThreadLocal

`ThreadLocal` 是 Java 中的一个类，它提供了线程局部变量的机制。线程局部变量是一种特殊的变量，每个线程都有自己独立的副本，互不干扰。`ThreadLocal` 主要用于在多线程环境下存储和访问与线程相关的数据，而不需要显式地进行线程同步。

以下是 `ThreadLocal` 的关键特点和用途：

1. **线程独立性**：每个线程都可以在 `ThreadLocal` 中存储自己的数据，而这些数据对其他线程是不可见的。这保证了线程之间的数据隔离，避免了竞争条件和线程安全性问题。

2. **线程上下文**：`ThreadLocal` 通常用于存储线程的上下文信息，例如用户身份认证信息、数据库连接、会话对象等。这些数据可以在整个线程的执行过程中方便地访问，而不需要将它们作为参数传递给每个方法。

3. **减少线程同步**：使用 `ThreadLocal` 可以减少线程之间的竞争条件，因为每个线程都有自己的数据副本，不需要进行显式的线程同步（例如，使用 `synchronized` 关键字）来保护共享数据。

4. **内存泄漏风险**：需要小心使用 `ThreadLocal`，因为如果不妥善管理，它可能导致内存泄漏问题。当 `ThreadLocal` 中存储的数据在不再需要时没有被正确清理时，会导致数据一直存在于内存中，占用内存资源。

使用 `ThreadLocal` 的基本步骤如下：

1. 创建 `ThreadLocal` 对象。
2. 在每个线程中使用 `set()` 方法设置线程局部变量的值。
3. 在需要访问线程局部变量的地方，使用 `get()` 方法获取当前线程的变量值。
4. 最后，为了避免内存泄漏，需要在不再需要使用线程局部变量时调用 `remove()` 方法将其从当前线程中移除。

需要注意的是，虽然 `ThreadLocal` 在某些情况下很有用，但滥用它可能导致代码的可读性下降和潜在的内存泄漏问题。因此，在使用时应仔细考虑场景，并确保正确清理不再需要的线程局部变量。

### 线程池



### 同步锁，synchronized

`synchronized` 是 Java 中用于实现线程同步的一个关键字。当多个线程需要访问共享资源时，为了保证资源的安全访问，需要使用同步机制来确保在任一时刻只有一个线程能够访问共享资源。`synchronized` 可以用于修饰方法或者以同步块的形式存在。以下是 `synchronized` 关键字的使用示例：

1. **修饰方法**:
```java
public class SynchronizedExample {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized void decrement() {
        count--;
    }

    public synchronized int getCount() {
        return count;
    }

    public static void main(String[] args) {
        SynchronizedExample example = new SynchronizedExample();
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                example.increment();
            }
        });
        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                example.decrement();
            }
        });

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(example.getCount());  // Output: 0
    }
}
```

在上述代码中，`increment`, `decrement`, 和 `getCount` 方法被 `synchronized` 关键字修饰。这意味着在任一时刻，只有一个线程可以执行这些方法中的任何一个。

2. **同步块**:
```java
public class SynchronizedBlockExample {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized (lock) {
            count++;
        }
    }

    public void decrement() {
        synchronized (lock) {
            count--;
        }
    }

    public int getCount() {
        synchronized (lock) {
            return count;
        }
    }

    // ... main 方法与上述相同 ...
}
```

在此示例中，我们使用了一个同步块来保护 `count` 变量。我们创建了一个 `lock` 对象，并将 `synchronized` 块与此对象一起使用，以确保在任一时刻只有一个线程可以执行 `synchronized` 块中的代码。

### 同步块

在Java中，同步块（synchronized block）是用来标记方法或代码块为同步，以控制对共享资源的并发访问。一个同步块是由`synchronized`关键字和一个锁对象组成的，它可以用于任何对象，以控制对该对象的访问。使用同步块可以保证在任何时刻，只有一个线程可以执行该块内的代码。

以下是同步块的使用示例:（lock对象作为一个资源，只能被一个进程同时占用）

```java
public class Counter {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized (lock) {
            count++;
            System.out.println("Incremented to: " + count);
        }
    }

    public void decrement() {
        synchronized (lock) {
            count--;
            System.out.println("Decremented to: " + count);
        }
    }

    public int getCount() {
        synchronized (lock) {
            return count;
        }
    }

    public static void main(String[] args) {
        Counter counter = new Counter();

        Thread incrementThread = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        Thread decrementThread = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.decrement();
            }
        });

        incrementThread.start();
        decrementThread.start();

        try {
            incrementThread.join();
            decrementThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Final count: " + counter.getCount());
    }
}
```

在这个例子中:

1. **定义锁对象**:
   定义了一个`Object`类型的`lock`对象作为锁。

2. **同步块**:
   `increment`, `decrement`, 和 `getCount` 方法内部都包含了使用`lock`对象的`synchronized`块。这些块确保在任何时刻只有一个线程可以执行块内的代码。

3. **线程创建和执行**:
   创建了两个线程，一个线程执行`increment`方法，另一个线程执行`decrement`方法。由于这些方法是同步的，因此在任何时刻只有一个线程可以执行。这确保了`count`变量的正确更新，避免了并发问题。 

4. **线程同步**:
   使用`join`方法等待两个线程完成执行，然后输出最终的`count`值。

通过这个例子，可以看到同步块如何帮助控制并发访问，保证数据的完整性和一致性。在实际开发中，选择正确的锁对象和合适的同步块是实现多线程安全的关键。

### 怎么设置线程池的线程数

参考：[[zhihu](https://zhuanlan.zhihu.com/p/407807591)]