### @Configuration注解

在Spring Boot中，`@Configuration`注解用于标注一个类，表明该类是一个配置类，可以用于定义一些Bean的创建和配置。

具体来说，`@Configuration`注解与`@Bean`注解一起使用，用于替代传统的XML配置文件方式，通过Java类来完成Spring框架中的配置工作。使用`@Configuration`注解后，Spring容器会扫描该类中的`@Bean`注解，将标记的方法返回的对象加入到Spring容器中，供其他类使用。

`@Configuration`注解主要有以下特点：

1. 与XML配置文件等价 通过`@Configuration`注解，我们可以在Java类中定义Spring Bean，这等价于在XML配置文件中定义Bean。
2. 可以用于替代XML配置文件 使用Java类代替XML配置文件的方式更加方便和灵活，可以方便地利用Java的面向对象特性实现复杂的配置逻辑。
3. 可以配合其他注解一起使用 `@Configuration`注解可以和其他注解一起使用，例如`@ComponentScan`、`@EnableWebMvc`等注解，来完成更加复杂的配置逻辑。

总之，`@Configuration`注解是Spring Boot中非常重要的一个注解，可以用于定义Bean、完成配置工作，从而更加方便、灵活地构建应用程序。

### @RestController和@Controller注解的区别

在Spring Boot中，`@RestController`和`@Controller`注解都用于标注控制器类，但是它们之间有以下几个区别：

1. 默认返回类型不同 `@Controller`注解用于标注控制器类，通常用于处理用户请求，并返回一个视图页面。在使用`@Controller`注解时，需要在控制器方法中使用`ModelAndView`对象封装数据和视图。

`@RestController`注解也用于标注控制器类，但是其默认返回的是JSON数据格式，通常用于处理RESTful接口请求。在使用`@RestController`注解时，可以直接在控制器方法中返回一个Java对象，Spring Boot框架会自动将其转换为JSON格式返回给客户端。

1. 返回值处理方式不同 `@Controller`注解使用`ViewResolver`进行视图解析，将模型数据与视图模板结合生成HTML等格式的文档返回给客户端。

`@RestController`注解则是将控制器方法返回的数据直接写入HTTP响应体中，使用Spring框架提供的`HttpMessageConverter`将Java对象转换为指定格式的数据（如JSON、XML等），最终返回给客户端。

1. 注解含义不同 `@Controller`注解表明这个类是Spring MVC中的控制器，用于处理HTTP请求，并返回一个模型数据和一个视图对象。

`@RestController`注解则是将`@Controller`和`@ResponseBody`注解组合在一起的快捷方式，表明这个类是Spring MVC中的控制器，同时返回的对象会被Spring自动序列化成JSON/XML等格式，直接返回给客户端。

综上所述，`@RestController`注解是一种快捷方式，用于简化RESTful接口的开发，而`@Controller`注解用于处理视图请求，返回HTML等格式的文档。

### @Autowire和@Resource

默认情况下，`@Autowired`注解是按照类型进行自动装配。

`@Resource`注解默认按照Bean的名称进行自动装配。

当容器中有一个类型的多个对象时，@Resoure根据名称区分对象，@Autowire和@Qualifier一起使用可以在容器中创建多个对象。

当一个类型（类）在Spring容器中有多个候选的Bean时，使用`@Autowired`注解会导致依赖注入的歧义性，并且在容器初始化时会抛出`NoUniqueBeanDefinitionException`异常。这是因为Spring无法确定要注入哪一个Bean。

解决这种歧义性的问题有几种方式：

1. **使用`@Qualifier`注解**：
   `@Qualifier`注解用于指定要注入的Bean的名称或ID，通过与`@Autowired`一起使用，可以解决歧义性问题。

   示例：

   ```java
   @Component
   public class MyService {
       private final MyRepository repository;
   
       @Autowired
       public MyService(@Qualifier("myRepositoryImpl1") MyRepository repository) {
           this.repository = repository;
       }
   }
   ```

   在上面的示例中，通过`@Qualifier("myRepositoryImpl1")`指定了要注入的Bean的名称为"myRepositoryImpl1"，这样Spring就可以找到具体要注入的Bean。

2. **使用`@Primary`注解**：
   `@Primary`注解用于指定在存在多个候选Bean的情况下，首选的Bean。当存在多个相同类型的Bean时，带有`@Primary`注解的Bean会成为首选的注入目标。

   示例：

   ```java
   @Component
   @Primary
   public class MyRepositoryImpl1 implements MyRepository {
       // 实现代码
   }
   
   @Component
   public class MyRepositoryImpl2 implements MyRepository {
       // 实现代码
   }
   
   @Component
   public class MyService {
       private final MyRepository repository;
   
       @Autowired
       public MyService(MyRepository repository) {
           this.repository = repository;
       }
   }
   ```

   在上面的示例中，由于`MyRepositoryImpl1`带有`@Primary`注解，因此在`MyService`中自动注入时会选择`MyRepositoryImpl1`作为首选的注入目标。

请注意，上述两种方法可以单独使用，也可以组合使用。如果同时使用`@Primary`和`@Qualifier`，`@Qualifier`的优先级更高。

另外，也可以考虑使用`@Resource`注解，它可以通过指定Bean的名称来解决歧义性问题，例如：`@Resource(name = "myRepositoryImpl1")`。

总结起来，通过合理使用`@Qualifier`、`@Primary`和`@Resource`注解，可以解决在一个类型有多个类时使用`@Autowired`注解引起的歧义性问题。