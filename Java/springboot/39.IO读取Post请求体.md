### IO读取Post请求体

- `StringBuffer`

  Java中的StringBuffer是一个可变字符串类，它允许在字符串中插入、删除和替换字符，而无需创建新的字符串对象。

  StringBuffer和String类有相似的方法，例如charAt()、substring()和length()等，但StringBuffer还有一些额外的方法来支持字符串的修改操作，例如insert()、append()、delete()和replace()等。

  与String不同的是，StringBuffer是可变的，这意味着可以在原始字符串对象上直接进行操作，而不需要创建一个新的字符串对象来保存修改后的结果。这对于需要频繁修改字符串的操作非常有用，因为避免了创建多个字符串对象的开销。

  另外，由于StringBuffer是线程安全的，可以在多线程环境下使用，而StringBuilder是非线程安全的，只能在单线程环境下使用。

  下面是一些StringBuffer的示例代码：

  ```java
  StringBuffer sb = new StringBuffer("Hello");
  sb.append(" World");
  System.out.println(sb.toString()); // 输出 "Hello World"
  
  sb.insert(5, " my");
  System.out.println(sb.toString()); // 输出 "Hello my World"
  
  sb.delete(5, 8);
  System.out.println(sb.toString()); // 输出 "Hello World"
  
  sb.replace(6, 11, "Java");
  System.out.println(sb.toString()); // 输出 "Hello Java"
  ```

- `StringBuffer`和`StringJoiner`的区别

  StringBuffer和StringJoiner都是用于处理字符串的类，但它们有不同的使用场景和特点。

  StringBuffer主要是用于在已有字符串的基础上进行字符串的操作，比如插入、删除、替换等，它是一个可变字符串类，可以在同一个对象上进行多次操作，避免了创建多个字符串对象的开销。另外，由于StringBuffer是线程安全的，也可以在多线程环境下使用。

  而StringJoiner主要是用于将一组字符串连接起来，它的设计初衷是为了方便构建字符串列表、数组等，支持在字符串之间添加分隔符，同时还可以在开头和结尾添加前缀和后缀。相比于使用StringBuffer来拼接字符串，使用StringJoiner更加简洁、易读、易于维护。但是，它不支持像StringBuffer那样的修改操作，一旦创建了StringJoiner对象，就无法对其内容进行修改，需要重新创建一个新的StringJoiner对象。

  下面是一个使用StringJoiner的示例代码：

  ```java
  StringJoiner sj = new StringJoiner(", ", "[", "]");
  sj.add("apple");
  sj.add("banana");
  sj.add("orange");
  String result = sj.toString();
  System.out.println(result); // 输出 "[apple, banana, orange]"
  ```

  总的来说，StringBuffer适用于需要在字符串中进行频繁的修改操作，而StringJoiner适用于将一组字符串连接起来的场景。

- `BufferedReader`

  BufferedReader是Java中的一个输入流类，它继承自Reader类，可以用于读取字符流。BufferedReader的主要作用是提供缓冲机制，可以在读取大量字符数据时提高读取效率，因为每次读取的是一块缓冲区中的数据，而不是每次都去访问磁盘或网络。

  BufferedReader的构造方法有多种重载形式，其中一个常用的构造方法是接收Reader对象作为参数，例如：

  ```java
  FileReader fileReader = new FileReader("example.txt");
  BufferedReader bufferedReader = new BufferedReader(fileReader);
  ```

  上面的代码创建了一个FileReader对象来读取名为example.txt的文件，然后将FileReader对象作为参数传递给BufferedReader的构造方法，创建了一个BufferedReader对象。

  BufferedReader提供了许多有用的方法，其中最常用的方法是readLine()方法，该方法读取一行字符数据并返回一个字符串，遇到文件结尾或者读取到换行符时返回null。下面是一个示例代码：

  ```java
  BufferedReader bufferedReader = new BufferedReader(new FileReader("example.txt"));
  String line;
  while ((line = bufferedReader.readLine()) != null) {
      System.out.println(line);
  }
  ```

  上面的代码打开了名为example.txt的文件，使用BufferedReader逐行读取文件内容并输出到控制台。使用BufferedReader可以减少文件访问的次数，提高读取效率，特别是在处理大型文件时。

  除了readLine()方法之外，BufferedReader还提供了其他一些有用的方法，例如read()方法可以读取单个字符，skip()方法可以跳过指定数量的字符等。

==直接把json对象读到Reader流对象中==：

```java
// 除了使用@RequestBody注解接收json参数，还可以使用IO自己读取json参数
@PostMapping("/param/body2")
public String p7(Reader reader) {
    StringBuffer content = new StringBuffer("");
    try(BufferedReader bin = new BufferedReader(reader)) {
        var line = "";
        while ( (line = bin.readLine()) != null) {
            content.append(line);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
    return "读取请求体数据: " + content.toString();
}
```

测试：

```http
###
POST http://localhost:8080/param/body2
Content-Type: application/json

{"name":"lzh", "age":20, "sex":"m"}

```

### 接收数组参数

```java
// 接收数组参数
@GetMapping("/param/arr")
public String p8(Integer[] id) {
    List<Integer> ids = Arrays.stream(id).toList();
    return "接收数组参数：" + ids.toString();
}
```

测试：

```http
### 接收数组参数1
GET http://localhost:8080/param/arr?id=1&id=2&id=3

### 接收数组参数2
GET http://localhost:8080/param/arr?id=1,2,3
```

其中：

- Arrays.stream方法

  Arrays.stream()是Java 8中Arrays类中新增的一个静态方法，它可以将一个数组转换为一个流（Stream），方便进行流式操作。该方法有多个重载形式，可以接受不同类型的数组作为参数。

  例如，我们可以将一个整型数组转换为一个IntStream对象：

  ```java
  javaCopy codeint[] numbers = {1, 2, 3, 4, 5};
  IntStream stream = Arrays.stream(numbers);
  ```

  上面的代码将整型数组numbers转换为一个IntStream对象，该对象包含了数组中的所有元素。我们可以通过IntStream对象进行各种流式操作，例如对数组元素求和：

  ```java
  pythonCopy codeint[] numbers = {1, 2, 3, 4, 5};
  IntStream stream = Arrays.stream(numbers);
  int sum = stream.sum();
  System.out.println(sum); // 输出 15
  ```

  上面的代码先将整型数组numbers转换为IntStream对象，然后使用sum()方法对所有元素进行求和，并将结果输出到控制台。

  除了IntStream之外，Arrays.stream()方法还可以转换为其他类型的流，例如：

  - Arrays.stream(double[] array)：将一个double类型的数组转换为一个DoubleStream对象；
  - Arrays.stream(long[] array)：将一个long类型的数组转换为一个LongStream对象；
  - Arrays.stream(T[] array)：将一个引用类型的数组转换为一个Stream<T>对象，其中T是数组元素的类型。

  通过Arrays.stream()方法可以方便地将数组转换为流，并进行各种流式操作，例如过滤、映射、排序等。它是Java 8中常用的流操作之一，可以大大简化数组的处理。

- Arrays.stream().toList()方法

  在Java 8中，Arrays类提供了一个`stream()`方法，用于将数组转换为一个流（Stream）对象，该方法可以将数组转换为不同类型的流，例如IntStream、DoubleStream、LongStream和Stream<T>等。

  如果我们需要将数组转换为一个List集合对象，可以使用Arrays.stream()方法和`Collectors.toList()`方法的组合。示例如下：

  ```java
  sqlCopy codeint[] array = {1, 2, 3, 4, 5};
  List<Integer> list = Arrays.stream(array).boxed().collect(Collectors.toList());
  ```

  上面的代码将一个整型数组转换为一个Stream对象，然后使用`boxed()`方法将Stream中的原始类型元素转换为对应的包装类型，最后使用`Collectors.toList()`方法将Stream中的元素收集到一个List集合中。

  在Java 8之前，我们通常使用Arrays.asList()方法将数组转换为List集合对象，但是这种方式有一个限制，就是转换后的List集合是一个固定长度的集合，不能进行添加或删除元素的操作。使用Arrays.stream().toList()方法可以避免这个限制，得到一个可变长度的List集合。

  需要注意的是，使用Arrays.stream().toList()方法需要JDK 16及以上版本的支持。在较早的版本中，我们可以使用`Arrays.stream().collect(Collectors.toList())`方法来实现类似的功能。

