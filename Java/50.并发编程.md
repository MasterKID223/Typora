## 并发与多线程

### 线程安全

#### Object的wait和notify方法是什么

在Java中，`Object`类提供了`wait()`和`notify()`方法，这些方法用于实现线程间的协作和同步。

1. `wait()`方法：
   - `wait()`方法用于让当前线程进入等待状态，直到其他线程调用了该对象的`notify()`或`notifyAll()`方法，或者指定的等待时间到期。
   - 当一个线程调用了`wait()`方法后，它会释放对象的锁（即使它是在同步块中调用的）并进入等待状态，直到其他线程通过调用`notify()`或`notifyAll()`来唤醒它，或者等待时间到期。
   - 如果`wait()`方法不带参数，那么线程将一直等待，直到其他线程调用了`notify()`或`notifyAll()`方法来唤醒它。
   - 如果`wait(long timeout)`方法带有超时参数，线程将在指定的时间内等待，如果超时时间到了，它将被唤醒。

2. `notify()`方法：
   - `notify()`方法用于唤醒正在等待该对象锁的线程中的一个线程，具体是哪一个线程取决于调度器。
   - 如果有多个线程在等待，那么只有一个线程会被唤醒，其他线程仍然处于等待状态。
   - 如果没有线程在等待，`notify()`方法不会产生任何作用。

3. `notifyAll()`方法：
   - `notifyAll()`方法用于唤醒所有正在等待该对象锁的线程。
   - 如果有多个线程在等待，它们都会被唤醒。
   - 如果没有线程在等待，`notifyAll()`方法不会产生任何作用。

这些方法通常用于多线程编程中的同步和协作，以确保线程间的正确通信和资源共享。

#### CAS

CAS 是 Compare and Swap 的缩写，中文翻译为比较并交换。在 Java 并发编程中，CAS 是一种乐观锁定机制，用于实现非阻塞算法。它主要由以下三个操作组成：

1. **比较 (Compare)**：CAS 首先比较当前内存中某个位置的值与预期的值是否相等。

2. **交换 (Swap)**：如果相等，则将该位置的值替换为新的值；如果不相等，则不进行任何操作。

3. **更新 (Update)**：CAS 操作是原子的，因此只有在比较相等且替换值的过程中才会更新。

CAS 的基本原理是，如果当前内存值与预期值相等，则将新值替换进去；如果不相等，则表示该位置已经被其他线程修改过，CAS 操作失败。由于 CAS 操作是原子性的，因此可以在多线程环境中确保共享变量的线程安全性，而不需要使用显式的锁。

在 Java 中，CAS 操作由 `java.util.concurrent.atomic` 包下的原子类来实现，例如 `AtomicInteger`、`AtomicLong` 等。这些原子类提供了 CAS 操作的实现，允许开发者在并发环境中安全地执行一些基本的原子操作，而无需使用显式的锁定。CAS 操作的性能通常比传统的锁定机制更高，因为它避免了线程阻塞和上下文切换的开销。

### JUC种的锁

#### 偏向锁、乐观锁

偏向锁（Biased Locking）和乐观锁（Optimistic Locking）是在并发编程中常用的两种锁机制。

1. **偏向锁**：偏向锁是为了解决在没有竞争的情况下，对于同步块的加锁和解锁的性能开销。当一个线程访问同步块并获取锁时，会在对象头上的标记位上记录该线程偏向于这个锁。之后，该线程再次进入同步块时，不需要进行同步操作，直接可以访问，从而提高了性能。但是如果其他线程尝试获取这个锁，则会撤销偏向锁，转换为常规的锁竞争模式。

2. **乐观锁**：乐观锁假设冲突的概率较低，因此允许多个线程同时访问数据，但在更新数据时进行检查以确保没有其他线程已经修改了该数据。通常使用版本号或时间戳等机制来实现。如果检测到数据被其他线程修改，就会进行回滚或者重新尝试。

总的来说，偏向锁适用于热点数据，假设同一线程会多次获得锁的情况；而乐观锁适用于冲突少，读操作多的情况，可以提高并发性能。