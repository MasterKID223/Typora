## mybatis-plus

### 基础用法

MyBatis-Plus（简称 MP）是一个基于 MyBatis 的增强工具，它简化了 MyBatis 的使用并提供了更多的功能。以下是 MyBatis-Plus 的基础用法：

1. **导入依赖**：

   首先，在你的项目中添加 MyBatis-Plus 的依赖，通常可以通过 Maven 或 Gradle 进行导入。

   ```xml
   <!-- Maven 依赖 -->
   <dependency>
       <groupId>com.baomidou</groupId>
       <artifactId>mybatis-plus</artifactId>
       <version>最新版本</version>
   </dependency>
   ```

2. **配置数据源和 MyBatis-Plus**：

   在 Spring Boot 项目中，你需要在配置文件（如 `application.properties` 或 `application.yml`）中配置数据源和 MyBatis-Plus 相关属性。下面是一个示例配置：

   ```yaml
   spring:
     datasource:
       url: jdbc:mysql://localhost:3306/mydb
       username: your_username
       password: your_password
       driver-class-name: com.mysql.cj.jdbc.Driver

   mybatis-plus:
     mapper-locations: classpath:mapper/*.xml
     global-config:
       db-config:
         id-type: auto
   ```

   这里配置了数据源的连接信息，指定了 MyBatis-Plus 的 Mapper 文件位置，并启用了主键自动生成策略（`id-type: auto`）。

3. **创建实体类**：

   创建与数据库表对应的实体类，通常使用注解来标记字段和表信息，如 `@TableName` 和 `@TableField`。

   ```java
   import com.baomidou.mybatisplus.annotation.TableName;
   import lombok.Data;

   @Data
   @TableName("user")
   public class User {
       private Long id;
       private String username;
       private String email;
   }
   ```

4. **创建 Mapper 接口**：

   创建一个继承自 `BaseMapper` 的接口，不需要编写实现类，MyBatis-Plus 会自动生成对应的 SQL 查询方法。

   ```java
   import com.baomidou.mybatisplus.core.mapper.BaseMapper;

   public interface UserMapper extends BaseMapper<User> {
   }
   ```

5. **使用 Mapper 进行数据库操作**：

   在业务逻辑中，通过注入 `UserMapper` 来使用 MyBatis-Plus 提供的数据访问方法。

   ```java
   @Service
   public class UserService {
       @Autowired
       private UserMapper userMapper;

       public User getUserById(Long id) {
           return userMapper.selectById(id);
       }

       public void createUser(User user) {
           userMapper.insert(user);
       }

       public void updateUser(User user) {
           userMapper.updateById(user);
       }

       public void deleteUser(Long id) {
           userMapper.deleteById(id);
       }
   }
   ```

6. **高级查询**：

   MyBatis-Plus 支持通过自定义条件构建器 `QueryWrapper` 来实现复杂的查询条件，例如：

   ```java
   QueryWrapper<User> wrapper = new QueryWrapper<>();
   wrapper.eq("username", "john")
          .like("email", "@example.com")
          .ge("id", 10)
          .orderByDesc("id");
   List<User> users = userMapper.selectList(wrapper);
   ```

7. **分页查询**：

   MyBatis-Plus 支持分页查询，可以使用 `Page` 对象来实现分页查询。

   ```java
   Page<User> page = new Page<>(1, 10); // 第一页，每页10条记录
   userMapper.selectPage(page, null);
   List<User> userList = page.getRecords();
   ```

这是 MyBatis-Plus 的基本用法概述。它提供了许多其他功能，如自定义查询方法、乐观锁支持、逻辑删除等。你可以根据项目需求深入学习和使用这些功能。同时，官方文档也提供了详细的使用说明和示例代码，可供参考。

### mapper.xml文件

`mapper.xml` 文件是 MyBatis 框架中用于配置 SQL 映射关系和具体 SQL 语句的文件。这些文件通常与 Java 的 Mapper 接口结合使用，用于定义如何将数据库操作与 Java 方法相对应。

一个典型的 `mapper.xml` 文件包含以下内容：

1. **命名空间（Namespace）**：定义了该 XML 文件与哪个 Java Mapper 接口相关联。

   ```xml
   <mapper namespace="com.example.mapper.UserMapper">
   ```

2. **SQL 映射**：在 `mapper.xml` 文件中，你可以定义各种 SQL 语句，包括查询、插入、更新和删除等。

   ```xml
   <select id="selectUserById" resultType="com.example.model.User">
       SELECT * FROM user WHERE id = #{id}
   </select>

   <insert id="insertUser" parameterType="com.example.model.User">
       INSERT INTO user (username, email) VALUES (#{username}, #{email})
   </insert>

   <update id="updateUser" parameterType="com.example.model.User">
       UPDATE user SET username = #{username}, email = #{email} WHERE id = #{id}
   </update>

   <delete id="deleteUser" parameterType="java.lang.Long">
       DELETE FROM user WHERE id = #{id}
   </delete>
   ```

3. **参数映射**：在 SQL 语句中，可以使用 `#{}` 占位符来引用方法参数或对象属性，MyBatis 会将这些占位符替换为实际的参数值。

4. **结果映射**：在查询语句中，可以使用 `resultType` 或 `resultMap` 来指定查询结果的映射类型，通常是一个 Java 对象，MyBatis 会将查询结果映射为这个对象的属性。

5. **参数映射**：在插入、更新和删除语句中，可以使用 `parameterType` 指定传递给 SQL 语句的参数类型。

6. **动态 SQL**：MyBatis 支持动态 SQL，你可以使用条件判断、循环等语句来构建动态的 SQL 查询，以根据不同的条件生成不同的 SQL 语句。

7. **SQL 片段**：你可以在 `mapper.xml` 中定义一些可重用的 SQL 片段，然后在不同的 SQL 语句中引用这些片段。

8. **其它配置**：除了 SQL 映射外，`mapper.xml` 文件还可以包含一些其它的配置，例如缓存配置、结果集映射规则、数据库连接池配置等。

总之，`mapper.xml` 文件是 MyBatis 中用于定义 SQL 映射和数据库操作的重要配置文件，它将 SQL 语句和 Java 方法关联起来，使开发人员能够轻松地执行数据库操作并将结果映射为 Java 对象。在 MyBatis 中，`mapper.xml` 文件通常与对应的 Mapper 接口一起使用，以提供数据库操作的实现细节。

### 分页查询

分页查询是一种数据库查询技术，用于从数据库表中检索数据的一部分，而不是检索整个数据集。这在处理大量数据或在Web应用程序中显示数据列表时非常有用。分页查询通常包括以下关键概念：

1. **页大小（Page Size）**：页大小指定每个查询结果页面中包含的数据行数。例如，如果页大小设置为10，那么每个页面将包含10行数据。

2. **当前页（Current Page）**：当前页表示用户当前查看的页码。用户可以通过界面进行切换。通常，第一页的页码是1。

3. **总记录数（Total Records）**：总记录数表示数据库表中满足查询条件的总数据行数。这是用来计算总页数的依据。

4. **总页数（Total Pages）**：总页数表示根据总记录数和页大小计算出来的总页码数量。

5. **起始索引和结束索引**：这是用于在数据库中截取数据的索引范围。通常，根据当前页和页大小，计算出起始索引和结束索引，然后从数据库中获取这个范围内的数据。

分页查询通常用于将大量数据划分成小块，以便于显示和导航。例如，在Web应用程序中，当用户查看产品列表、搜索结果、或者社交媒体的帖子时，通常会使用分页查询来限制每次加载的数据量，以确保页面加载速度快，并减轻服务器和数据库的负载。

分页查询也可以与排序一起使用，以便用户能够根据某些条件对数据进行排序，并在不同页面之间保持一致的排序顺序。

在SQL中，通常使用`LIMIT`和`OFFSET`（或类似的关键字，具体取决于数据库系统）来执行分页查询。这些关键字用于指定从查询结果中获取的行的范围。例如，`LIMIT 10 OFFSET 20`表示获取从第21行到第30行的数据。

分页查询对于提高用户体验和优化数据库性能都非常重要，因为它允许在处理大量数据时有效地管理和检索数据。

#### PaginationInnerInterceptor

`PaginationInnerInterceptor` 是一个类，通常与 MyBatis Plus（一种基于 MyBatis 的持久层框架）一起使用。它是 MyBatis Plus 提供的一个内部分页拦截器，用于处理分页查询。

这个拦截器的主要作用是在执行数据库查询时，自动添加分页相关的 SQL 语句（如 LIMIT、OFFSET）以实现分页功能，而无需手动编写这些 SQL 语句。这可以大大简化分页查询的代码编写，并提高代码的可维护性。

通常，你可以在 MyBatis Plus 的配置文件中配置 `PaginationInnerInterceptor`，并将它添加到 MyBatis 的拦截器链中。这样，当你执行带有分页条件的查询时，`PaginationInnerInterceptor` 会自动处理分页逻辑。

以下是一个示例配置 `PaginationInnerInterceptor` 的代码片段：

```java
import com.baomidou.mybatisplus.extension.plugins.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MyBatisPlusConfig {

    @Bean
    public PaginationInnerInterceptor paginationInnerInterceptor() {
        return new PaginationInnerInterceptor();
    }
}
```

上述代码中，我们将 `PaginationInnerInterceptor` 注册为一个 Spring Bean，并在配置中使用它。你可以根据具体的项目需求进行配置，例如设置分页参数的命名规则、启用 count SQL 优化等。

总之，`PaginationInnerInterceptor` 是 MyBatis Plus 提供的一个用于简化分页查询的重要组件，它可以帮助你轻松实现数据库查询的分页功能。

### IService

`IService` 是一个接口，通常在使用 MyBatis-Plus 这个持久层框架时会遇到。MyBatis-Plus 是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。`IService` 是 MyBatis-Plus 提供的一个核心接口，用于封装常见的 CRUD（Create、Read、Update、Delete）操作。

在实际应用中，你通常会创建一个业务服务接口，这个接口会继承 `IService`，这样你的业务服务接口就会自动拥有一系列 CRUD 的方法，无需自己重新定义。

例如：

```java
public interface IUserService extends IService<User> {
    // 你可以在这里定义你的自定义业务方法
}
```

这样，`IUserService` 接口就继承了如下一些常见的方法：

- `save(T entity)`：插入一条记录
- `removeById(Serializable id)`：根据 ID 删除一条记录
- `updateById(T entity)`：根据 ID 选择性更新一条记录
- `list()`：查询所有记录
- `getById(Serializable id)`：根据 ID 查询一条记录
- ...等等

当你创建一个实现了 `IUserService` 的类时，你可以使用这些方法而无需自己实现它们。

```java
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {
    // 自定义业务逻辑
}
```

注意，这里的 `ServiceImpl` 是 MyBatis-Plus 提供的一个基础实现类，它实现了 `IService` 接口。

使用 `IService` 可以让代码更加简洁，更加集中于业务逻辑的实现，而不是常规 CRUD 操作的实现。这也是使用 MyBatis-Plus 的一个主要优点。

下面的示例是一个非常基础的 Spring Boot + MyBatis-Plus 项目，用于演示如何使用 `IService` 接口。在这个例子中，我们将创建一个简单的用户管理系统，其中包含一个 `User` 实体和相关的 CRUD 操作。

#### 1. 添加依赖

在 `pom.xml` 文件中添加 Spring Boot 和 MyBatis-Plus 的依赖。

```xml
<!-- Spring Boot Starter Web -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- MyBatis-Plus -->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.3.3</version> <!-- 请检查最新版本 -->
</dependency>
```

#### 2. 创建 User 实体

创建一个 `User` 实体类。

```java
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;

public class User {
    @TableId(type = IdType.AUTO)
    private Long id;
    private String name;
    private Integer age;

    // getter 和 setter
}
```

#### 3. 创建 Mapper 接口

创建一个继承 `BaseMapper` 的 `UserMapper` 接口。

```java
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

public interface UserMapper extends BaseMapper<User> {
}
```

#### 4. 创建 IService 接口和实现类

创建一个继承 `IService` 的 `UserService` 接口。

```java
import com.baomidou.mybatisplus.extension.service.IService;

public interface UserService extends IService<User> {
}
```

接着，创建 `UserService` 的实现类。

```java
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {
}
```

#### 5. 创建 Controller

创建一个 `UserController`，注入 `UserService`，并实现基本的 CRUD 操作。

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/user")
public class UserController {
    @Autowired
    private UserService userService;

    @GetMapping("/list")
    public List<User> listUsers() {
        return userService.list();
    }

    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.getById(id);
    }

    @PostMapping("/add")
    public boolean addUser(@RequestBody User user) {
        return userService.save(user);
    }

    @PutMapping("/update")
    public boolean updateUser(@RequestBody User user) {
        return userService.updateById(user);
    }

    @DeleteMapping("/delete/{id}")
    public boolean deleteUser(@PathVariable Long id) {
        return userService.removeById(id);
    }
}
```

现在，你有了一个简单的 Spring Boot + MyBatis-Plus 项目，其中使用了 `IService` 接口来简化 CRUD 操作。你可以通过 RESTful API 来进行用户的增加、删除、修改和查询操作。

这只是一个非常基础的例子，你可以根据需要进行扩展。希望这个例子能够帮助你更好地理解如何在 Spring Boot + MyBatis-Plus 的项目中使用 `IService`。

### ofType和javaType

在 MyBatis 中，`ofType` 和 `javaType` 都是用于指定 Java 类型的属性，但它们分别在不同的场景下使用。

1. **javaType**：
   
   `javaType` 是在 `<result>` 或 `<resultMap>` 元素中使用的属性，用于指定数据库列和 Java 类型之间的映射关系。

   例如，如果你有一个数据库表的列名为 `name`，类型为 `VARCHAR`，并且你希望这个列映射到 Java 中的 `String` 类型，你可以这样做：
   ```xml
   <result column="name" javaType="java.lang.String" />
   ```

   通常，MyBatis 能够自动推断大部分的 `javaType`，所以你不必总是明确指定它。但在某些情况下，明确指定 `javaType` 可以避免类型的歧义。

2. **ofType**：

   `ofType` 属性通常用在 `<collection>` 和 `<association>` 元素中，它指定了关联或集合的元素类型。

   例如，考虑以下场景：一个 `Author` 有多个 `Book`。你可以使用 `ofType` 指定 `Book` 的类型如下：
   ```xml
   <collection property="books" ofType="com.example.Book">
       ...
   </collection>
   ```

总结：
- 当你在 `<result>` 或 `<resultMap>` 中定义单个字段的映射时，使用 `javaType`。
- 当你在定义 `<collection>` 或 `<association>` 的映射时，使用 `ofType` 指定关联对象或集合的元素类型。

注意：在实践中，如果你的命名和结构足够清晰，MyBatis 大部分时间都能够自动推断出正确的类型。但明确指定可以确保你的代码更加健壮和清晰。

### type和javaType

在 MyBatis 的上下文中，`type` 和 `javaType` 之间的差异主要在于它们的应用场景和目的。

1. **javaType**：

    `javaType` 通常在 `<result>` 或 `<resultMap>` 元素中使用，它明确指定了数据库列的值应该映射到的 Java 类型。例如，你可能希望将数据库中的 `VARCHAR` 类型映射到 Java 中的 `String` 类型：
    ```xml
    <result column="name" javaType="java.lang.String" />
    ```
    MyBatis 通常能够自动推断大部分的 `javaType`，但在某些情况下，明确指定 `javaType` 可以避免类型的歧义。

2. **type**：

    - 在 `<resultMap>` 上下文中：`type` 指定了这个结果映射应该映射到的 Java 类型（通常是一个 POJO）。
    ```xml
    <resultMap id="userMap" type="com.example.User">
        ...
    </resultMap>
    ```
    在这里，`type` 告诉 MyBatis 结果应该被映射到 `com.example.User` 类型的对象。

    - 在 `TypeHandler` 上下文中：`type` 用于指定这个类型处理器应用到的 Java 类型。
    ```xml
    <typeHandler handler="com.example.MyCustomTypeHandler" type="java.lang.String" />
    ```
    在这里，`type` 表示 `com.example.MyCustomTypeHandler` 这个类型处理器应该应用于 Java 的 `String` 类型。

总的来说，虽然 `type` 和 `javaType` 都与 Java 类型有关，但它们在 MyBatis 的配置中的具体含义和应用场景是不同的：

- `javaType` 主要用于 `<result>` 元素，定义如何将数据库列映射到具体的 Java 类型。
- `type` 可以在 `<resultMap>` 中定义映射到的 Java POJO，或在 `TypeHandler` 的上下文中定义应用的 Java 类型。

### association的作用

在 MyBatis 中，`<association>` 标签主要用于描述一对一 (1:1) 的关系。当你在查询中需要映射一个对象内的另一个复杂对象时，你会用到 `<association>`。

简单来说，`<association>` 允许你映射查询结果的一部分到一个 Java Bean 中的另一个 Java Bean。这是在构建具有丰富域模型或包含多个关联对象的数据模型时非常有用的。

考虑以下例子：

假设你有两个数据库表：`users` 和 `addresses`。每个用户在 `users` 表中都有一个条目，而他们的地址在 `addresses` 表中。

你的 Java 对象模型可能如下：

```java
public class User {
    private int id;
    private String name;
    private Address address;  // 注意这里，一个用户有一个地址对象
    // ... getters and setters ...
}

public class Address {
    private int id;
    private String street;
    private String city;
    // ... getters and setters ...
}
```

当你想要从数据库查询用户及其关联的地址时，你可以使用 `<association>` 来映射地址数据：

```xml
<resultMap id="userResultMap" type="User">
    <id property="id" column="user_id" />
    <result property="name" column="user_name" />
    
    <association property="address" javaType="Address">
        <id property="id" column="address_id" />
        <result property="street" column="street_name" />
        <result property="city" column="city_name" />
    </association>
</resultMap>
```

在上述的 `resultMap` 中，主要数据映射到 `User` 对象，但是通过 `<association>`，我们也映射了与用户关联的地址数据到 `User` 对象中的 `Address` 对象。

总的来说，`<association>` 在 MyBatis 中用于处理一对一的关系，允许你在单个查询中映射和填充多个相关的对象。