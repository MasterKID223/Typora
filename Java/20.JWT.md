### 登录业务中的JWT

==携带jwt令牌的时候，Bearer后要加一个空格，标识使用的是oauth协议==

JWT（JSON Web Token）是一种用于在网络应用间传递信息的开放标准（RFC 7519）。它被设计为在客户端和服务器之间安全地传输被称为声明（claims）的JSON对象。

在登录场景中，JWT通常用作身份验证和授权机制。当用户通过用户名和密码成功登录后，服务器会生成一个JWT并将其返回给客户端。客户端在后续的请求中使用该JWT作为身份验证凭证。

JWT由三个部分组成，使用点号（.）分隔开来：
1. Header（头部）：包含有关令牌类型（即JWT）和所使用的签名算法的元数据。
2. Payload（负载）：包含称为声明的数据，这些声明用于存储有关用户或其他实体的信息以及其他相关元数据。
3. Signature（签名）：使用服务器端密钥对头部和负载进行签名，以确保令牌的完整性和身份验证。

在每次请求中，客户端将JWT放置在请求的头部或有效负载中，以便服务器可以验证该令牌并对其进行授权。服务器使用密钥来验证签名，并从负载中提取必要的信息以进行身份验证和授权操作。JWT还可以包含过期时间等元数据，以确保令牌在一段时间后自动失效，提高安全性。

由于JWT包含所有必要的信息，服务器不需要存储会话状态或在数据库中查询用户信息，因此它可以支持无状态（stateless）的身份验证机制，从而简化了系统的复杂性和扩展性。

需要注意的是，JWT本身是基于令牌的身份验证机制，但并不提供加密功能。因此，在使用JWT时，应该确保令牌在传输过程中通过安全通道进行传输，以防止被中间人窃取或篡改。

<img src="./pic/image-20240223232453406.png" alt="image-20240223232453406" style="zoom:50%;" />

<img src="./pic/image-20240223232630691.png" alt="image-20240223232630691" style="zoom: 50%;" />

### 无状态认证

使用JWT可以实现无状态认证，什么是无状态认证？

传统的基于session的方式是有状态认证，用户登录成功将用户的身份信息存储在服务端，这样加大了服务端的存储压力，并且这种方式不适合在分布式系统中应用。

如下图，当用户访问应用服务，每个应用服务都会去服务器查看session信息，如果session中没有该用户则说明用户没有登录，此时就会重新认证，而解决这个问题的方法是Session复制、Session黏贴。

![image-20240223232756670](./pic/image-20240223232756670.png)

如果是基于令牌技术在分布式系统中实现认证则服务端不用存储session，可以将用户身份信息存储在令牌中，用户认证通过后认证服务颁发令牌给用户，用户将令牌存储在客户端，去访问应用服务时携带令牌去访问，服务端从jwt解析出用户信息。这个过程就是无状态认证。

![image-20240223232815946](./pic/image-20240223232815946.png)

### JWT的优缺点

1、jwt基于json，非常方便解析。

2、可以在令牌中自定义丰富的内容，易扩展。

3、通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。

4、资源服务使用JWT可不依赖认证服务即可完成授权。

缺点：

１、JWT令牌较长，占存储空间比较大。

下边是一个JWT令牌的示例：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX25hbWUiOiJ6aGFuZ3NhbiIsInNjb3BlIjpbImFsbCJdLCJleHAiOjE2NjQyNTQ2NzIsImF1dGhvcml0aWVzIjpbInAxIl0sImp0aSI6Ijg4OTEyYjJkLTVkMDUtNGMxNC1iYmMzLWZkZTk5NzdmZWJjNiIsImNsaWVudF9pZCI6ImMxIn0.wkDBL7roLrvdBG2oGnXeoXq-zZRgE9IVV2nxd-ez_oA
```

JWT令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz（header.payload.signature）

1. Header    

 头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA）

 一个例子如下：

 下边是Header部分的内容

```json
 {
    "sub": "1234567890",
    "name": "456",
    "admin": true
  }
```

 将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。

2. Payload

 第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的信息字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。

 此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。

 最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。

 一个例子：

```json
{
    "sub": "1234567890",
    "name": "456",
    "admin": true
  }
```



3. Signature

 第三部分是签名，此部分用于防止jwt内容被篡改。

 这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明的签名算法进行签名。

 一个例子：

```json
HMACSHA256(
    base64UrlEncode(header) + "." +
    base64UrlEncode(payload),
    secret)
```

base64UrlEncode(header)：jwt令牌的第一部分。

base64UrlEncode(payload)：jwt令牌的第二部分。

secret：签名所使用的密钥。

### 为什么JWT可以防止篡改？

有加密算法，用同样的密钥解析出来的令牌得一样。

![image-20240223233244702](./pic/image-20240223233244702.png)

### 网关认证

![image-20240224013042826](./pic/image-20240224013042826.png)