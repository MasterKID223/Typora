## Docker的基本使用

参考：[[csdn](https://blog.csdn.net/qq_38140292/article/details/123256877)]

### 安装

参考菜鸟教程。

 阿里云镜像加速器：[[aliyun](https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors)]

### 部署springboot项目

参考：[[csdn](https://blog.csdn.net/m0_58847451/article/details/129774170)]

好的，这里给一个具体的例子，假设您有一个名为 myapp 的 Spring Boot 应用程序，需要将其运行在 Docker 中。

1. 创建 Dockerfile：在 myapp 项目的根目录下创建一个 Dockerfile 文件，内容如下：

```dockerfile
FROM openjdk:8-jdk-alpine

COPY target/myapp.jar /app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

这个 Dockerfile 使用 openjdk:8-jdk-alpine 作为基础镜像，并将 myapp 项目打包出来的 JAR 文件复制到容器中。容器的 8080 端口也被暴露出来，这是因为 Spring Boot 默认使用的是 8080 端口。最后，使用 ENTRYPOINT 指令设置容器启动时运行的命令。

2. 构建 Docker 镜像：在终端中进入到 myapp 项目的根目录下，然后运行以下命令来构建 Docker 镜像：

```shell
docker build -t myapp .
```

该命令会将 myapp 项目打包并构建出一个名为 myapp 的 Docker 镜像。

3. 运行 Docker 容器：使用以下命令来启动 Docker 容器：

```shell
docker run -p 8080:8080 myapp
```

该命令会启动一个名为 myapp 的容器，并将容器的 8080 端口映射到主机的 8080 端口。这样，您就可以通过浏览器访问 [http://localhost:8080](http://localhost:8080/) 来访问应用程序了。

注意，此示例假定您已经在 myapp 项目中使用 Maven 或 Gradle 打包出了一个可执行的 JAR 文件。如果您还没有打包应用程序，可以在项目的根目录下运行以下命令：

```shell
./mvnw package
```

或者

```shell
./gradlew bootJar
```

这将使用 Maven 或 Gradle 打包出一个可执行的 JAR 文件，然后将其保存到 target 目录下。之后，您就可以使用 Dockerfile 将该 JAR 文件打包成 Docker 镜像并在 Docker 容器中运行了。

==ADD和COPY的区别：==

`COPY` 和 `ADD` 都可以将文件复制到 Docker 镜像中，但它们之间有几个区别：

1. `COPY` 只能复制本地文件或目录，而 `ADD` 还支持从 URL、tar 文件和压缩文件中复制文件到镜像中。
2. `ADD` 在复制文件的同时，还会将其解压缩。因此，如果您需要将文件复制到镜像中并解压缩，可以使用 `ADD` 命令。
3. `ADD` 支持的选项比 `COPY` 更多，例如 `--chown` 选项可以设置文件的所有者和用户组，`--chmod` 选项可以设置文件的权限等。

在 Spring Boot 应用程序的情况下，通常使用 `COPY` 命令将可执行的 JAR 文件复制到镜像中，因为 JAR 文件不需要解压缩。因此，示例 Dockerfile 中使用了 `COPY` 命令：

```bash
COPY target/myapp.jar /app.jar
```

如果您需要复制并解压缩其他类型的文件，可以使用 `ADD` 命令。例如，以下命令将复制并解压缩名为 `myapp.tar.gz` 的文件到镜像中：

```bash
ADD myapp.tar.gz /app
```

### Docker push镜像

可能出现的问题：denied: requested access to the resource is denied.

解决：[[csdn](https://blog.csdn.net/qq_14997473/article/details/110917351)]

`docker tag` 命令用于给一个本地镜像打上一个指定的标签，以便将其推送到远程镜像仓库。它的基本语法如下：

```bash
docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
```

其中：

- `SOURCE_IMAGE[:TAG]`：要打标签的本地镜像的名称或 ID。可以包含可选的标签，例如 `my-image:latest`。
- `TARGET_IMAGE[:TAG]`：新标签的名称或 ID，用于标识已标记的镜像的位置。同样，可以包含可选的标签。

例如，要将名为 `my-image` 的本地镜像打上标签 `my-registry.com/my-image:v1` 并将其推送到远程镜像仓库，您可以执行以下命令：

```bash
docker tag my-image:latest my-registry.com/my-image:v1
```

这将为本地镜像 `my-image` 创建一个名为 `my-registry.com/my-image` 的新标签，版本号为 `v1`。接下来，您可以使用 `docker push` 命令将其推送到远程镜像仓库：

```bash
docker push my-registry.com/my-image:v1
```

注意，要成功推送标记的镜像，您必须先登录到远程镜像仓库，并具有相应的访问权限。

### 删除镜像

删除hub中的镜像，需要登录到hub网页中：

![image-20230506213437491](./pic/image-20230506213437491.png)



### docker基本命令

当使用 Docker 进行容器管理时，以下是一些基本的 Docker 命令和使用示例：

1. **镜像相关命令：**
   - `docker images`：列出本地已有的镜像。
   - `docker pull <image:tag>`：从 Docker 镜像仓库中下载指定的镜像。
   - `docker build -t <image:tag> <Dockerfile路径>`：根据 Dockerfile 构建一个新的镜像。
   - `docker push <image:tag>`：将本地的镜像推送到 Docker 镜像仓库。
   - `docker rmi <image_name:tag>`：用于删除本地的一个或多个镜像。`rmi` 是 "remove image" 的缩写。
   
2. **容器生命周期相关命令：**
   - `docker run <image:tag>`：创建并启动一个新的容器。
   - `docker start <container_id>`：启动一个已经停止的容器。
   - `docker stop <container_id>`：停止正在运行的容器。
   - `docker restart <container_id>`：重启一个容器。
   - `docker rm <container_id>`：删除一个已经停止的容器。
   - `docker ps`：列出正在运行的容器。
   - `docker ps -a`：列出所有的容器，包括已停止的容器。

3. **容器操作相关命令：**
   - `docker exec <container_id> <command>`：在运行的容器中执行指定的命令。
   - `docker attach <container_id>`：附加到正在运行的容器，可以查看容器的输出日志。
   - `docker logs <container_id>`：查看容器的日志输出。
   - `docker cp <container_id>:<source_path> <destination_path>`：将容器内的文件/目录复制到主机上。
   - `docker inspect <container_id>`：获取容器的详细信息。

4. **网络相关命令：**
   - `docker network ls`：列出 Docker 网络。
   - `docker network create <network_name>`：创建一个新的 Docker 网络。
   - `docker network connect <network_name> <container_id>`：将容器连接到指定的网络。
   - `docker network disconnect <network_name> <container_id>`：将容器从指定的网络中断开连接。

这些命令只是 Docker 命令的一小部分，可以帮助你开始使用 Docker。还有许多其他命令和选项可用于更高级的容器管理和操作。你可以使用 `docker --help` 命令查看完整的 Docker 命令列表，以及每个命令的详细说明和使用示例。

**命令行选项：**

在 Docker 中，`-e` 是一个用于设置环境变量的命令行选项。它用于在运行容器时将环境变量传递给容器内部的应用程序。

使用 `-e` 选项，你可以将键值对作为参数传递给 `docker run` 命令，然后在容器内部作为环境变量使用。例如：

```
docker run -e KEY=VALUE <image:tag>
```

上述命令将在运行容器时设置一个名为 `KEY` 的环境变量，并将其值设置为 `VALUE`。

在容器内部，你可以通过读取环境变量来访问传递的值。具体语法和方式取决于你所使用的编程语言或应用程序。

例如，在一个基于 Python 的应用程序中，你可以使用以下代码来访问环境变量：

```python
import os

value = os.environ.get('KEY')
print(value)
```

这将输出环境变量 `KEY` 的值。

通过使用 `-e` 选项，你可以方便地在运行容器时动态设置应用程序所需的配置信息，如数据库连接字符串、API 密钥等。这样，你可以在不修改容器镜像的情况下灵活地配置和部署容器化应用程序。

除了 `-e` 选项之外，Docker 还提供了其他一些常用的命令行选项用于容器的配置和运行，例如：

1. **-p 或 --publish**：用于将容器的端口映射到主机的端口，格式为 `-p host_port:container_port`。例如，`docker run -p 8080:80 <image:tag>` 将容器的 80 端口映射到主机的 8080 端口上。

2. **-v 或 --volume**：用于将主机上的目录或文件挂载到容器内部，格式为 `-v host_path:container_path`。例如，`docker run -v /host/path:/container/path <image:tag>` 将主机上的 `/host/path` 目录挂载到容器的 `/container/path` 目录。

3. **-d 或 --detach**：将容器在后台模式下运行，即使容器没有终端连接也可以保持运行。例如，`docker run -d <image:tag>`。

4. **--name**：为容器指定一个名称。例如，`docker run --name my_container <image:tag>`。

5. **--restart**：设置容器在退出时的重启策略。可以使用以下选项之一：`no`、`on-failure[:max-retries]`、`always`、`unless-stopped`。例如，`docker run --restart=always <image:tag>`。

6. **-it**：结合使用 `-i` 和 `-t` 选项，用于以交互模式启动容器，并分配一个伪终端。例如，`docker run -it <image:tag>`。

这些命令行选项提供了额外的配置和控制能力，以满足不同的容器运行需求。你可以根据需要使用这些选项来定制容器的行为。可以通过 docker run --help 命令获取更多关于 Docker 运行命令的详细信息。

#### docker ps

要查看已经启动的容器，可以使用`docker ps`命令。这个命令将列出所有正在运行的容器，并显示与它们相关的一些详细信息，如容器ID、镜像、创建时间、状态等。

在终端或命令行中执行以下命令即可查看已启动的容器：

```shell
docker ps
```

如果要查看包括已停止的容器在内的所有容器，可以使用`-a`选项：

```shell
docker ps -a
```

这将显示所有容器的列表，不论其状态是正在运行还是已停止。

#### docker run

`docker run` 是用于创建并运行容器的命令。以下是 `docker run` 的详细使用方式：

基本语法：
```
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

其中，`OPTIONS` 是一系列命令行选项，`IMAGE` 是要运行的镜像的名称或标识符，`COMMAND` 是容器启动时要执行的命令，`ARG...` 是传递给命令的参数。

常用选项包括：

- **-d, --detach**：在后台模式下运行容器。
- **-p, --publish**：将容器的端口映射到主机的端口。
- **-v, --volume**：挂载主机的目录或文件到容器内部。
- **-e, --env**：设置环境变量。
- **--name**：为容器指定一个名称。
- **--restart**：设置容器在退出时的重启策略。
- **-it**：以交互模式运行容器，并分配一个伪终端。

除了这些常用选项外，还有其他选项可用于更高级的容器配置和管理。

以下是 `docker run` 命令的示例用法：

1. 运行一个镜像：
```
docker run <image:tag>
```

2. 指定容器名称和端口映射：
```
docker run --name my_container -p 8080:80 <image:tag>
```

3. 挂载主机目录到容器内部：
```
docker run -v /host/path:/container/path <image:tag>
```

4. 设置环境变量：
```
docker run -e KEY=VALUE <image:tag>
```

5. 以交互模式运行容器：
```
docker run -it <image:tag>
```

这些示例仅展示了 `docker run` 命令的一小部分功能和选项。你可以根据具体需求使用适当的选项和参数，来创建和配置适合你的容器。使用 `docker run --help` 命令可以获取完整的命令用法和选项说明。

### Dockerfile编写

在编写 Dockerfile 时，你可以使用以下参数：

1. FROM：指定基础镜像，格式为 `FROM image:tag`。
2. MAINTAINER（已弃用）/ LABEL：用于指定镜像的作者和联系信息，格式为 `LABEL key=value`。
3. RUN：用于在容器内部执行命令，格式为 `RUN command`。可以使用多个 RUN 命令来运行多个命令，并且可以使用 && 来串联多个命令。
4. CMD：定义容器启动时要执行的默认命令。可以有多个 CMD 命令，但只有最后一个 CMD 命令会生效。
5. EXPOSE：声明容器在运行时监听的端口，格式为 `EXPOSE port`。
6. ENV：设置环境变量，格式为 `ENV key=value`。可以使用多个 ENV 命令来设置多个环境变量。
7. ADD/COPY：将本地文件复制到容器内部，格式为 `COPY source destination` 或 `ADD source destination`。COPY 只能复制本地文件，而 ADD 还支持解压缩和远程文件。
8. WORKDIR：指定容器的工作目录，格式为 `WORKDIR /path/to/directory`。
9. VOLUME：声明持久化挂载点，格式为 `VOLUME ["/data"]`。
10. ENTRYPOINT：配置容器启动时要执行的命令，可以与 CMD 配合使用。格式为 `ENTRYPOINT command`。
11. ARG：定义构建时的参数，格式为 `ARG key=value`。构建过程中可以使用这些参数，但在运行容器时不可用。
12. ONBUILD：定义触发器，当当前镜像被用作其他镜像的基础镜像时，会触发执行指定命令。
13. HEALTHCHECK：指定容器的健康检查命令，格式为 `HEALTHCHECK options CMD command`。

这些参数可以根据你的需求和具体的应用场景进行灵活组合和使用，以创建适合的 Docker 镜像。

例子：

```dockerfile
FROM openjdk:8
ENV workdir=/root/app/eureka-server
COPY . ${workdir}
WORKDIR ${workdir}
EXPOSE 8761
```

### docker中的一些基础概念

#### 镜像和容器

在 Docker 中，镜像（Image）和容器（Container）是两个关键概念，它们之间有着明显的区别和联系。

**镜像（Image）**是一个可执行的软件包，包含了运行特定应用程序所需的一切内容，包括代码、运行时环境、库文件、依赖项等。简单来说，镜像就是一个静态的文件，类似于一个模板或者快照，可以用来创建容器。镜像可以被制作、存储和共享，它们是 Docker 容器的基础。

**容器（Container）**是从镜像创建的运行实例。容器是镜像的动态状态，包含了正在运行的应用程序、其依赖项和所需的资源。每个容器都是独立、隔离的运行环境，可以在其中运行应用程序。容器提供了一种轻量级、可移植和可扩展的方式来打包和运行应用程序，而无需担心运行环境的差异和冲突。

关于镜像和容器之间的区别和联系，可以总结如下：

**区别**：
- 镜像是静态的文件，用于创建容器；容器是运行中的实例，基于镜像创建并具有独立的运行环境。
- 镜像包含了应用程序的代码、依赖项和运行时环境，是应用程序的静态描述；容器包含了镜像的副本，并添加了运行时状态和资源。
- 镜像可以被制作、存储和共享；容器是临时的，可以创建、启动、停止、删除。

**联系**：

- 容器是基于镜像创建的，每个容器都有一个关联的镜像。
- 镜像提供了创建容器所需的所有文件和配置信息。
- 镜像可以作为容器的模板，可以在多个容器之间共享和复用。
- 镜像可以更新和版本化，以便在需要时重新创建容器。
- 容器可以与其他容器和主机进行通信，共享资源和网络连接。

总而言之，镜像是应用程序的静态描述和模板，而容器是镜像的动态运行实例。镜像提供了一种可复制和可共享的打包机制，容器提供了一种轻量级、可隔离和可扩展的运行环境。

### 在ubuntu中安装docker

要在Ubuntu上安装Docker，您可以按照以下步骤进行操作：

**注意：**在执行以下步骤之前，请确保您具有管理员权限或sudo访问权限。

1. 更新系统软件包列表：

```bash
sudo apt update
```

2. 安装一些必要的软件包，以便可以通过HTTPS使用存储库：

```bash
sudo apt install apt-transport-https ca-certificates curl software-properties-common
```

3. 添加Docker官方存储库的GPG密钥：

```bash
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
```

4. 添加Docker存储库：

```bash
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```

5. 更新软件包列表，以便包含Docker存储库：

```bash
sudo apt update
```

6. 安装Docker引擎：

```bash
sudo apt install docker-ce
```

7. 启动Docker服务并设置其在系统启动时自动启动：

```bash
sudo systemctl start docker
sudo systemctl enable docker
```

8. 验证Docker安装是否成功，可以运行以下命令检查Docker版本：

```bash
docker --version
```

您现在应该已经成功安装了Docker。您可以使用Docker运行容器化的应用程序和服务。如果需要，还可以安装Docker Compose来管理多个容器。

### Docker网络配置

Docker 的网络功能提供了容器间的通信机制，同时也管理容器与外部世界的连接。理解 Docker 网络对于配置和管理 Docker 容器非常重要。以下是 Docker 网络的主要类型及其配置方法的概述：

#### Docker 网络的类型

1. **桥接网络（Bridge）**：
   - 这是默认的网络模式。当运行一个未指定网络的容器时，它会自动连接到一个默认的桥接网络。
   - 容器在桥接网络中拥有自己的私有网络地址，并且通过网络地址转换（NAT）与外部世界通信。
   - 使用 `-p` 或 `--publish` 参数映射端口可以使外部网络访问到容器。

2. **主机网络（Host）**：
   - 使用主机网络的容器共享主机的网络命名空间，不进行网络隔离。
   - 这意味着容器直接使用主机的 IP 地址和端口，不需要端口映射。
   - 在性能要求高的情况下（如需要避免网络延迟或端口转发的开销）使用。

3. **覆盖网络（Overlay）**：
   - 用于 Docker Swarm 集群，可以在多个 Docker 主机上的容器之间提供网络连接。
   - 允许不同 Docker 守护进程的容器互相通信，适用于大规模的应用部署。

4. **无网络（None）**：
   - 设置为 `none` 的容器没有网络接口。
   - 这通常用于完全隔离的环境中。

5. **MACVLAN**：
   - MACVLAN 网络允许容器拥有自己的 MAC 地址，并且像是网络上的物理设备一样。
   - 适用于需要容器在物理网络上直接可见的高级场景。

#### 配置 Docker 网络

1. **创建自定义桥接网络**：
   ```bash
   docker network create --driver bridge my_bridge
   ```

2. **启动容器并连接到特定网络**：
   
   ```bash
   docker run --network=my_bridge -d my_image
   ```
   
3. **端口映射**：
   - 当使用桥接网络时，如果需要从外部访问容器内部的服务，需要设置端口映射：
   ```bash
   docker run -p 8080:80 my_image
   ```
   - 这里，主机的 8080 端口映射到容器的 80 端口。

4. **检查网络配置**：
   - 查看所有网络：
     ```bash
     docker network ls
     ```
   - 检查特定网络的详细信息：
     ```bash
     docker network inspect my_bridge
     ```

5. **连接/断开容器与网络**：
   
   - 将运行中的容器连接到网络：
     ```bash
     docker network connect my_bridge my_container
     ```
   - 从网络断开容器：
     ```bash
     docker network disconnect my_bridge my_container
     ```
   
6. **网络清理**：
   - 删除不再使用的网络可以帮助维护 Docker 环境的整洁：
     ```bash
     docker network prune
     ```

#### 注意事项

- **安全性**：使用主机网络模式时，容器的网络安全和主机一致，这可能增加安全风险。
- **性能**：网络模式选择应考虑性能和隔离之间的平衡。例如，桥接网络提供了较好的隔离，但可能比主机网络稍微慢一些。
- **端口冲突**：在主机网络模式下，如果容器内的服务使用的端口已经被主机上的其他服务占用，会导致冲突。
- **跨主机通信**：对于多

主机部署，覆盖网络提供了容器间的无缝通信机制。

了解这些网络类型及其配置方式是管理 Docker 容器的关键。根据您的应用需求和部署环境，选择合适的网络类型和配置策略至关重要。

#### 查看某个容器的网络配置

要查看 Docker 中某个容器的网络模式，您可以使用 `docker inspect` 命令，它提供了关于容器配置的详细信息，包括网络设置。以下是具体的步骤：

1. 首先，找到您想要检查的容器的 ID 或名称。如果您不知道容器的 ID 或名称，可以使用 `docker ps` 或 `docker ps -a` 命令列出所有运行中或所有容器。

2. 然后，使用 `docker inspect` 命令加上容器的 ID 或名称来获取详细信息。例如：

   ```bash
   docker inspect [container_id_or_name]
   ```

   将 `[container_id_or_name]` 替换为实际的容器 ID 或名称。

3. 在输出的 JSON 数据中，查找 `NetworkSettings` 部分。该部分包含了有关容器网络配置的信息，包括网络模式（如 `Bridge`, `Host`, `None` 等）。

   如果您想要更直接地查看网络模式，可以使用以下命令：

   ```bash
   docker inspect --format='{{.HostConfig.NetworkMode}}' [container_id_or_name]
   ```

   ```bash
   docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' elasticsearch
   ```
   
   这将直接输出该容器的网络模式。

这些命令对于深入理解容器的网络配置和故障排除非常有用。通过检查容器的网络设置，您可以更好地了解容器如何与其他容器以及宿主机进行通信。

### 虚拟机挂起再恢复docker0消失

==解决方法：重启虚拟机。==

当虚拟机挂起再恢复后，如果发现`docker0`网卡消失，这通常是由于网络服务没有正确恢复导致的。可以尝试以下几个步骤来解决这个问题：

1. **重启网络服务**：有时候，简单地重启网络服务可以解决这个问题。你可以使用类似`sudo systemctl restart network`的命令来重启网络服务，具体命令取决于你的操作系统和网络管理工具。

2. **重启Docker服务**：如果重启网络服务没有解决问题，尝试重启Docker服务。使用`sudo systemctl restart docker`命令来重启Docker服务。

3. **检查Docker配置**：确保Docker配置正确。检查`/etc/docker/daemon.json`文件（如果存在），确保里面的配置没有错误。

4. **检查虚拟机的网络设置**：确保虚拟机的网络设置没有改变，特别是在挂起和恢复过程中。

5. **查看系统日志**：查看系统日志文件，如`/var/log/syslog`或`/var/log/messages`，可能会提供一些关于问题的线索。

6. **重新安装Docker**：如果上述步骤都无法解决问题，可以考虑重新安装Docker。有时候，重新安装可以修复由于配置问题或其他原因造成的问题。

在执行这些步骤时，请确保你有足够的权限来执行系统级别的命令。如果问题依然存在，建议查阅具体的虚拟机和Docker文档，或者在相关论坛和社区寻求帮助。