## Docker的基本使用

参考：[[csdn](https://blog.csdn.net/qq_38140292/article/details/123256877)]

### 安装

参考菜鸟教程。

 阿里云镜像加速器：[[aliyun](https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors)]

### 部署springboot项目

参考：[[csdn](https://blog.csdn.net/m0_58847451/article/details/129774170)]

好的，这里给一个具体的例子，假设您有一个名为 myapp 的 Spring Boot 应用程序，需要将其运行在 Docker 中。

1. 创建 Dockerfile：在 myapp 项目的根目录下创建一个 Dockerfile 文件，内容如下：

```dockerfile
FROM openjdk:8-jdk-alpine

COPY target/myapp.jar /app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

这个 Dockerfile 使用 openjdk:8-jdk-alpine 作为基础镜像，并将 myapp 项目打包出来的 JAR 文件复制到容器中。容器的 8080 端口也被暴露出来，这是因为 Spring Boot 默认使用的是 8080 端口。最后，使用 ENTRYPOINT 指令设置容器启动时运行的命令。

2. 构建 Docker 镜像：在终端中进入到 myapp 项目的根目录下，然后运行以下命令来构建 Docker 镜像：

```shell
docker build -t myapp .
```

该命令会将 myapp 项目打包并构建出一个名为 myapp 的 Docker 镜像。

3. 运行 Docker 容器：使用以下命令来启动 Docker 容器：

```shell
docker run -p 8080:8080 myapp
```

该命令会启动一个名为 myapp 的容器，并将容器的 8080 端口映射到主机的 8080 端口。这样，您就可以通过浏览器访问 [http://localhost:8080](http://localhost:8080/) 来访问应用程序了。

注意，此示例假定您已经在 myapp 项目中使用 Maven 或 Gradle 打包出了一个可执行的 JAR 文件。如果您还没有打包应用程序，可以在项目的根目录下运行以下命令：

```shell
./mvnw package
```

或者

```shell
./gradlew bootJar
```

这将使用 Maven 或 Gradle 打包出一个可执行的 JAR 文件，然后将其保存到 target 目录下。之后，您就可以使用 Dockerfile 将该 JAR 文件打包成 Docker 镜像并在 Docker 容器中运行了。

==ADD和COPY的区别：==

`COPY` 和 `ADD` 都可以将文件复制到 Docker 镜像中，但它们之间有几个区别：

1. `COPY` 只能复制本地文件或目录，而 `ADD` 还支持从 URL、tar 文件和压缩文件中复制文件到镜像中。
2. `ADD` 在复制文件的同时，还会将其解压缩。因此，如果您需要将文件复制到镜像中并解压缩，可以使用 `ADD` 命令。
3. `ADD` 支持的选项比 `COPY` 更多，例如 `--chown` 选项可以设置文件的所有者和用户组，`--chmod` 选项可以设置文件的权限等。

在 Spring Boot 应用程序的情况下，通常使用 `COPY` 命令将可执行的 JAR 文件复制到镜像中，因为 JAR 文件不需要解压缩。因此，示例 Dockerfile 中使用了 `COPY` 命令：

```bash
COPY target/myapp.jar /app.jar
```

如果您需要复制并解压缩其他类型的文件，可以使用 `ADD` 命令。例如，以下命令将复制并解压缩名为 `myapp.tar.gz` 的文件到镜像中：

```bash
ADD myapp.tar.gz /app
```

### Docker push镜像

可能出现的问题：denied: requested access to the resource is denied.

解决：[[csdn](https://blog.csdn.net/qq_14997473/article/details/110917351)]

`docker tag` 命令用于给一个本地镜像打上一个指定的标签，以便将其推送到远程镜像仓库。它的基本语法如下：

```bash
docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
```

其中：

- `SOURCE_IMAGE[:TAG]`：要打标签的本地镜像的名称或 ID。可以包含可选的标签，例如 `my-image:latest`。
- `TARGET_IMAGE[:TAG]`：新标签的名称或 ID，用于标识已标记的镜像的位置。同样，可以包含可选的标签。

例如，要将名为 `my-image` 的本地镜像打上标签 `my-registry.com/my-image:v1` 并将其推送到远程镜像仓库，您可以执行以下命令：

```bash
docker tag my-image:latest my-registry.com/my-image:v1
```

这将为本地镜像 `my-image` 创建一个名为 `my-registry.com/my-image` 的新标签，版本号为 `v1`。接下来，您可以使用 `docker push` 命令将其推送到远程镜像仓库：

```bash
docker push my-registry.com/my-image:v1
```

注意，要成功推送标记的镜像，您必须先登录到远程镜像仓库，并具有相应的访问权限。

### 删除镜像

删除hub中的镜像，需要登录到hub网页中：

![image-20230506213437491](./pic/image-20230506213437491.png)



### docker基本命令

当使用 Docker 进行容器管理时，以下是一些基本的 Docker 命令和使用示例：

1. **镜像相关命令：**
   - `docker images`：列出本地已有的镜像。
   - `docker pull <image:tag>`：从 Docker 镜像仓库中下载指定的镜像。
   - `docker build -t <image:tag> <Dockerfile路径>`：根据 Dockerfile 构建一个新的镜像。
   - `docker push <image:tag>`：将本地的镜像推送到 Docker 镜像仓库。
   - `docker rmi <image_name:tag>`：用于删除本地的一个或多个镜像。`rmi` 是 "remove image" 的缩写。
   
2. **容器生命周期相关命令：**
   - `docker run <image:tag>`：创建并启动一个新的容器。
   - `docker start <container_id>`：启动一个已经停止的容器。
   - `docker stop <container_id>`：停止正在运行的容器。
   - `docker restart <container_id>`：重启一个容器。
   - `docker rm <container_id>`：删除一个已经停止的容器。
   - `docker ps`：列出正在运行的容器。
   - `docker ps -a`：列出所有的容器，包括已停止的容器。

3. **容器操作相关命令：**
   - `docker exec <container_id> <command>`：在运行的容器中执行指定的命令。
   - `docker attach <container_id>`：附加到正在运行的容器，可以查看容器的输出日志。
   - `docker logs <container_id>`：查看容器的日志输出。
   - `docker cp <container_id>:<source_path> <destination_path>`：将容器内的文件/目录复制到主机上。
   - `docker inspect <container_id>`：获取容器的详细信息。

4. **网络相关命令：**
   - `docker network ls`：列出 Docker 网络。
   - `docker network create <network_name>`：创建一个新的 Docker 网络。
   - `docker network connect <network_name> <container_id>`：将容器连接到指定的网络。
   - `docker network disconnect <network_name> <container_id>`：将容器从指定的网络中断开连接。

这些命令只是 Docker 命令的一小部分，可以帮助你开始使用 Docker。还有许多其他命令和选项可用于更高级的容器管理和操作。你可以使用 `docker --help` 命令查看完整的 Docker 命令列表，以及每个命令的详细说明和使用示例。

**命令行选项：**

在 Docker 中，`-e` 是一个用于设置环境变量的命令行选项。它用于在运行容器时将环境变量传递给容器内部的应用程序。

使用 `-e` 选项，你可以将键值对作为参数传递给 `docker run` 命令，然后在容器内部作为环境变量使用。例如：

```
docker run -e KEY=VALUE <image:tag>
```

上述命令将在运行容器时设置一个名为 `KEY` 的环境变量，并将其值设置为 `VALUE`。

在容器内部，你可以通过读取环境变量来访问传递的值。具体语法和方式取决于你所使用的编程语言或应用程序。

例如，在一个基于 Python 的应用程序中，你可以使用以下代码来访问环境变量：

```python
import os

value = os.environ.get('KEY')
print(value)
```

这将输出环境变量 `KEY` 的值。

通过使用 `-e` 选项，你可以方便地在运行容器时动态设置应用程序所需的配置信息，如数据库连接字符串、API 密钥等。这样，你可以在不修改容器镜像的情况下灵活地配置和部署容器化应用程序。

除了 `-e` 选项之外，Docker 还提供了其他一些常用的命令行选项用于容器的配置和运行，例如：

1. **-p 或 --publish**：用于将容器的端口映射到主机的端口，格式为 `-p host_port:container_port`。例如，`docker run -p 8080:80 <image:tag>` 将容器的 80 端口映射到主机的 8080 端口上。

2. **-v 或 --volume**：用于将主机上的目录或文件挂载到容器内部，格式为 `-v host_path:container_path`。例如，`docker run -v /host/path:/container/path <image:tag>` 将主机上的 `/host/path` 目录挂载到容器的 `/container/path` 目录。

3. **-d 或 --detach**：将容器在后台模式下运行，即使容器没有终端连接也可以保持运行。例如，`docker run -d <image:tag>`。

4. **--name**：为容器指定一个名称。例如，`docker run --name my_container <image:tag>`。

5. **--restart**：设置容器在退出时的重启策略。可以使用以下选项之一：`no`、`on-failure[:max-retries]`、`always`、`unless-stopped`。例如，`docker run --restart=always <image:tag>`。

6. **-it**：结合使用 `-i` 和 `-t` 选项，用于以交互模式启动容器，并分配一个伪终端。例如，`docker run -it <image:tag>`。

这些命令行选项提供了额外的配置和控制能力，以满足不同的容器运行需求。你可以根据需要使用这些选项来定制容器的行为。可以通过 docker run --help 命令获取更多关于 Docker 运行命令的详细信息。

#### docker ps

要查看已经启动的容器，可以使用`docker ps`命令。这个命令将列出所有正在运行的容器，并显示与它们相关的一些详细信息，如容器ID、镜像、创建时间、状态等。

在终端或命令行中执行以下命令即可查看已启动的容器：

```shell
docker ps
```

如果要查看包括已停止的容器在内的所有容器，可以使用`-a`选项：

```shell
docker ps -a
```

这将显示所有容器的列表，不论其状态是正在运行还是已停止。

#### docker run

`docker run` 是用于创建并运行容器的命令。以下是 `docker run` 的详细使用方式：

基本语法：
```
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

其中，`OPTIONS` 是一系列命令行选项，`IMAGE` 是要运行的镜像的名称或标识符，`COMMAND` 是容器启动时要执行的命令，`ARG...` 是传递给命令的参数。

常用选项包括：

- **-d, --detach**：在后台模式下运行容器。
- **-p, --publish**：将容器的端口映射到主机的端口。
- **-v, --volume**：挂载主机的目录或文件到容器内部。
- **-e, --env**：设置环境变量。
- **--name**：为容器指定一个名称。
- **--restart**：设置容器在退出时的重启策略。
- **-it**：以交互模式运行容器，并分配一个伪终端。

除了这些常用选项外，还有其他选项可用于更高级的容器配置和管理。

以下是 `docker run` 命令的示例用法：

1. 运行一个镜像：
```
docker run <image:tag>
```

2. 指定容器名称和端口映射：
```
docker run --name my_container -p 8080:80 <image:tag>
```

3. 挂载主机目录到容器内部：
```
docker run -v /host/path:/container/path <image:tag>
```

4. 设置环境变量：
```
docker run -e KEY=VALUE <image:tag>
```

5. 以交互模式运行容器：
```
docker run -it <image:tag>
```

这些示例仅展示了 `docker run` 命令的一小部分功能和选项。你可以根据具体需求使用适当的选项和参数，来创建和配置适合你的容器。使用 `docker run --help` 命令可以获取完整的命令用法和选项说明。

### Dockerfile编写

在编写 Dockerfile 时，你可以使用以下参数：

1. FROM：指定基础镜像，格式为 `FROM image:tag`。
2. MAINTAINER（已弃用）/ LABEL：用于指定镜像的作者和联系信息，格式为 `LABEL key=value`。
3. RUN：用于在容器内部执行命令，格式为 `RUN command`。可以使用多个 RUN 命令来运行多个命令，并且可以使用 && 来串联多个命令。
4. CMD：定义容器启动时要执行的默认命令。可以有多个 CMD 命令，但只有最后一个 CMD 命令会生效。
5. EXPOSE：声明容器在运行时监听的端口，格式为 `EXPOSE port`。
6. ENV：设置环境变量，格式为 `ENV key=value`。可以使用多个 ENV 命令来设置多个环境变量。
7. ADD/COPY：将本地文件复制到容器内部，格式为 `COPY source destination` 或 `ADD source destination`。COPY 只能复制本地文件，而 ADD 还支持解压缩和远程文件。
8. WORKDIR：指定容器的工作目录，格式为 `WORKDIR /path/to/directory`。
9. VOLUME：声明持久化挂载点，格式为 `VOLUME ["/data"]`。
10. ENTRYPOINT：配置容器启动时要执行的命令，可以与 CMD 配合使用。格式为 `ENTRYPOINT command`。
11. ARG：定义构建时的参数，格式为 `ARG key=value`。构建过程中可以使用这些参数，但在运行容器时不可用。
12. ONBUILD：定义触发器，当当前镜像被用作其他镜像的基础镜像时，会触发执行指定命令。
13. HEALTHCHECK：指定容器的健康检查命令，格式为 `HEALTHCHECK options CMD command`。

这些参数可以根据你的需求和具体的应用场景进行灵活组合和使用，以创建适合的 Docker 镜像。

例子：

```dockerfile
FROM openjdk:8
ENV workdir=/root/app/eureka-server
COPY . ${workdir}
WORKDIR ${workdir}
EXPOSE 8761
```

