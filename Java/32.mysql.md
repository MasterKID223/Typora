## mysql基础

### 递归查询

MySQL本身不支持递归查询，但您可以使用一些技巧来实现递归查询。递归查询通常用于处理树形结构的数据，比如组织结构或者分类目录。以下是一种使用常见的"递归查询"方法来查询树形结构数据的示例：

假设您有一个表格名为`categories`，其中包含以下字段：
- `category_id`：分类的唯一标识符
- `name`：分类的名称
- `parent_id`：父分类的category_id

要查询某个特定分类及其所有子分类，可以使用MySQL的`WITH RECURSIVE`语句（递归公共表表达式）。以下是一个示例：

```sql
WITH RECURSIVE CategoryPath AS (
  SELECT category_id, name, parent_id
  FROM categories
  WHERE category_id = 1  -- 1是您要查询的特定分类的category_id
  UNION ALL
  SELECT c.category_id, c.name, c.parent_id
  FROM categories c
  JOIN CategoryPath cp ON c.parent_id = cp.category_id
)
SELECT category_id, name
FROM CategoryPath;
```

上面的SQL查询将返回category_id为1的分类以及其所有子分类。这个查询首先选择了根分类（category_id为1），然后通过`UNION ALL`递归地将其子分类添加到结果中，直到没有更多子分类为止。

请注意，递归查询在MySQL中可能会变得相当复杂，特别是对于大型数据集。确保数据库表格中的数据结构适合进行递归查询，并谨慎使用递归查询，以避免性能问题。此外，某些MySQL版本可能需要在配置中启用递归查询功能。

如果您使用的是MySQL 8.0或更高版本，通常支持递归查询。如果您使用的是较旧的版本，可能需要升级到支持递归查询的版本或考虑使用其他数据库系统，如PostgreSQL，它具有更强大的递归查询功能。

### union all

`UNION ALL` 是一种用于合并两个或多个 SQL 查询结果集的操作符，它将结果集中的所有行都包括在最终结果中，包括重复的行。以下是关于 `UNION ALL` 的一些关键信息：

1. **合并多个查询结果集：** `UNION ALL` 允许您将多个 `SELECT` 查询的结果合并成一个结果集。这些查询必须具有相同数量的列，且每个列的数据类型必须兼容。

2. **保留重复行：** 与 `UNION` 不同，`UNION ALL` 不会去除结果集中的重复行。如果两个或多个查询的结果中存在相同的行，那么这些重复行都将包含在最终的合并结果中。

3. **性能：** 由于 `UNION ALL` 不执行重复行的去重操作，因此通常比 `UNION` 更快，尤其是在处理大型数据集时。如果您确定不需要去重操作，建议使用 `UNION ALL` 而不是 `UNION` 来提高查询性能。

以下是一个示例，说明如何使用 `UNION ALL` 合并两个查询结果集：

假设您有两个表格，一个是存储了所有员工的信息的 `employees` 表格，另一个是存储了所有合同员工的信息的 `contractors` 表格。您可以使用 `UNION ALL` 来将这两个表格的数据合并成一个结果集：

```sql
SELECT employee_id, first_name, last_name
FROM employees
UNION ALL
SELECT contractor_id, first_name, last_name
FROM contractors;
```

上面的查询将返回包含所有员工和合同员工信息的结果集，包括重复的行（如果有的话）。如果您希望去除重复的行，可以使用 `UNION` 替代 `UNION ALL`。

### 聚簇索引和非聚簇索引

聚簇索引（Clustered Index）是数据库中一种常见的索引类型，它与非聚簇索引（Non-clustered Index）相对。在理解聚簇索引之前，让我们先了解一下数据库索引的基本概念：

1. **索引（Index）**：索引是数据库表中一种特殊的数据结构，用于提高数据检索的速度。它类似于书籍的目录，可以根据索引中的键值快速找到相应的数据行。

2. **聚簇索引**：在聚簇索引中，数据行的物理顺序与索引的逻辑顺序相同，也就是说，数据行按照索引键的顺序存储在磁盘上。因此，一个表只能有一个聚簇索引。聚簇索引在数据库表的主键上创建，如果没有显式指定主键，则某些数据库系统会自动选择一个唯一非空索引作为聚簇索引。

3. **非聚簇索引**：与聚簇索引相反，非聚簇索引中索引的逻辑顺序与数据行的物理顺序不一定相同。在非聚簇索引中，索引条目包含指向实际数据行的指针（或引用），因此在进行数据检索时，首先需要查找索引，然后再根据索引中的指针找到实际的数据行。

聚簇索引的优点是能够提高数据检索的速度，因为数据行按照索引键的顺序存储在磁盘上，可以减少磁盘IO操作。但是，它也有一些缺点，比如当插入新数据时，可能需要移动已有的数据行，以保持索引键的顺序，这可能会导致性能下降。

### B+树搜索复杂度

对于有 N 个叶子节点的 B+Tree，其搜索复杂度为`O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。

b+树的深度是log_d^N：IO查询需要的时间更长，忽略在节点内部的查找时间复杂度。

### 伪列

在 MySQL 中，"伪列"（pseudocolumn）是指一种特殊的列，它们不是实际存储在数据库表中的数据，而是在查询过程中生成的虚拟列。MySQL 提供了几种不同的伪列，其中一些是用于特定的查询目的。

以下是 MySQL 中常见的一些伪列：

1. **ROWNUM**: 用于在结果集中返回行的序号。但是请注意，MySQL 本身并不直接提供 ROWNUM 伪列，相反，可以使用用户变量来模拟这种行为。

   ```sql
   SELECT @rownum := @rownum + 1 AS row_number, column1, column2
   FROM your_table, (SELECT @rownum := 0) r
   ```

2. **ROWID**: 用于访问表中的行的物理地址或标识符。在 MySQL 中，ROWID 不是直接可用的伪列，但可以使用 AUTO_INCREMENT 列来模拟此行为。

3. **CURDATE() 和 CURRENT_TIMESTAMP()**: 这些不是严格意义上的伪列，而是函数，但可以用于在查询中获取当前日期和时间。

   ```sql
   SELECT CURDATE() AS current_date, CURRENT_TIMESTAMP() AS current_timestamp;
   ```

4. **LAST_INSERT_ID()**: 用于获取最后插入行的 AUTO_INCREMENT 值。

   ```sql
   SELECT LAST_INSERT_ID() AS last_insert_id;
   ```

这些伪列可用于在查询中执行各种操作，从而使查询结果更具有灵活性和实用性。

==例子：==

当使用伪列时，一个常见的例子是在结果集中添加行号。虽然 MySQL 没有内置的 ROWNUM 伪列，但我们可以使用用户变量来模拟这种行为。下面是一个示例：

假设我们有一个名为 `employees` 的表，包含 `id`、`name` 和 `salary` 列，我们想要在查询结果中添加行号。

```sql
SELECT 
    @rownum := @rownum + 1 AS row_number,
    id,
    name,
    salary
FROM 
    employees, 
    (SELECT @rownum := 0) r;
```

在这个查询中，我们使用了 `@rownum` 用户变量来模拟行号。首先，我们初始化 `@rownum` 为 0，然后在查询中每次遍历结果集时，`@rownum` 递增一次，从而得到行号。

这将产生一个带有行号的结果集，类似于以下内容：

```
+------------+----+----------+--------+
| row_number | id |   name   | salary |
+------------+----+----------+--------+
|     1      | 1  | John     | 50000  |
|     2      | 2  | Jane     | 60000  |
|     3      | 3  | Alice    | 55000  |
|     ...    | .. | ...      | ...    |
+------------+----+----------+--------+
```

这样，我们就能够在结果集中方便地获得每行的序号，而无需在表结构中添加额外的列。

这部分 `(SELECT @rownum := 0) r` 是一个子查询，它的作用是初始化一个用户变量 `@rownum`。让我来解释一下：

1. `@rownum := 0`: 这是一个赋值语句，用于将值 0 赋给用户变量 `@rownum`。这个变量会在查询中被用来跟踪行号。

2. `(SELECT @rownum := 0)`: 这是一个子查询，它实际上没有从任何表中选择数据，而是执行了上述赋值语句。因为子查询本身没有实际的数据来源，所以我们用 `r` 给它起了一个别名，以便在主查询中引用。

3. 最后的 `r`：这是为子查询起的别名，这样我们就可以在主查询中引用它。在 MySQL 中，当我们需要在查询中执行一些操作而不直接从表中选择数据时，通常会使用子查询来完成。

总的来说，`(SELECT @rownum := 0) r` 的目的是在查询执行之前初始化 `@rownum` 变量，并且通过别名 `r` 在主查询中使用它。

### MVCC-多版本并发控制



### 读快照和当前读

读快照是ReadView，当前读是每次都从数据库中读取最新数据。

- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（==记录锁+间隙锁==）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

在 MySQL 中，记录锁（Record Lock）和间隙锁（Gap Lock）是两种用于控制并发访问的锁机制，用于确保数据的一致性和事务的隔离性。

1. **记录锁（Record Lock）**：
   记录锁是针对已经存在的数据行进行的锁定操作。当一个事务对某一行数据进行了修改时，该行会被记录锁定，以防止其他事务对其进行修改或删除，直到持有锁的事务释放锁为止。记录锁的范围是行级别，也就是说，它只会锁定指定行的数据。

2. **间隙锁（Gap Lock）**：
   间隙锁是针对数据范围的一种锁定操作，它锁定了一个范围内的数据间隙（即不存在的数据行之间的空间），以防止其他事务在这个范围内插入新的数据。间隙锁的目的是防止出现幻读（Phantom Read）现象，确保事务能够在读取数据时看到一个一致的数据集合。间隙锁的范围是索引键值之间的间隙，而不是实际的数据行。

在 MySQL 中，当使用 `SELECT ... FOR UPDATE` 或 `SELECT ... LOCK IN SHARE MODE` 语句时，会自动获取记录锁，以防止其他事务对选定的行进行修改。而在某些情况下，MySQL 会自动获取间隙锁，以保护数据范围，例如在使用范围条件进行查询时。

需要注意的是，记录锁和间隙锁的使用可能会影响并发性能，因此在设计数据库结构和编写 SQL 查询时应该谨慎考虑，并尽量避免不必要的锁定操作。
