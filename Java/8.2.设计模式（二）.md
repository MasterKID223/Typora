## 设计模式（二）

参考：[[掘金](https://juejin.cn/post/7199907126688825400#heading-0)]

### 9. 模板方法模式（Template Method Pattern）

Java 模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，并将一些步骤延迟到子类中实现。模板方法模式使得子类可以在不改变算法结构的情况下重定义算法中的某些步骤。

#### 使用场景

- 算法骨架固定：如果一个算法的基本结构已经固定，但具体的实现步骤可能因为不同的场景而不同，这个时候可以使用模板方法模式。
- 实现代码复用：如果有多个类的某些方法结构相似，但是实现细节不同，这个时候可以将这些相同的结构抽象到父类中，由子类来实现不同的细节。
- 简化代码实现：模板方法模式可以将复杂的代码实现分离成几个简单的步骤，从而降低代码实现的难度和复杂度。
- 框架和库的设计：模板方法模式是设计框架和库的重要方式之一，它可以提供统一的接口和标准的实现流程，方便用户进行扩展和定制

#### 代码实现

  `AbstractClass` 是一个抽象类，它定义了算法的骨架，其中 `templateMethod()` 是模板方法，它定义了算法的流程，由一些抽象方法 `primitiveOperation1()` 和 `primitiveOperation2()` 组成。

  `ConcreteClass` 是 `AbstractClass` 的具体子类，它实现了抽象方法，定义了具体的算法细节。在客户端使用时，创建 `ConcreteClass` ，然后调用其 `templateMethod()` 方法，即可完成算法的执行。

```
public abstract class AbstractClass {

    public final void templateMethod() {
        primitiveOp1();
        primitiveOp2();
    }

    public abstract void primitiveOp1();
    public abstract void primitiveOp2();
}
```

```java
public class ConcreteClass extends AbstractClass {
    @Override
    public void primitiveOp1() {
        System.out.println("算法步骤1");
    }

    @Override
    public void primitiveOp2() {
        System.out.println("算法步骤2");
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        AbstractClass abstractClass = new ConcreteClass();
        abstractClass.templateMethod();
    }
}
```

==需要注意的是，在模板方法模式中，模板方法通常被声明为 `final`，以防止子类对其进行重写。同时，由于模板方法是一个抽象方法，因此在实现时需要注意不同抽象方法的实现顺序，以确保算法的正确性。==

使用小结

很多框架类的设计都采用了模板方法模式，例如 Spring 中的 `JdbcTemplate`，其中定义了一套执行 SQL 的流程，并由子类实现具体的 SQL 语句

### 10. 命令模式（Command Pattern）

------

掘金博客中给出的例子，可能不恰当，参考chatgpt给出的例子。

<hr>

命令模式（Command Pattern）是一种行为型设计模式，它将请求封装成一个对象，从而使发送者和接收者之间解耦，并且可以灵活地参数化和传递请求。

在命令模式中，主要包含以下角色：

1. 命令（Command）：命令对象封装了一个特定的操作和接收者（执行该操作的对象）。它通常定义了一个执行操作的方法，如`execute()`，以及可能需要的其他方法（如`undo()`和`redo()`）。命令对象可以包含操作所需的参数和上下文信息。
2. 接收者（Receiver）：接收者是执行命令操作的对象。它包含实际执行操作的代码逻辑。命令对象将具体的操作委托给接收者执行。
3. 调用者（Invoker）：调用者持有一个命令对象，并负责触发命令的执行。它并不了解具体的操作和接收者的细节，只需通过命令对象的接口来调用执行命令的方法。
4. 客户端（Client）：客户端创建命令对象并将其与接收者关联起来。客户端可以配置命令对象的参数和上下文信息，并将命令对象传递给调用者进行调用。

命令模式的基本流程如下：

1. 客户端创建一个具体命令对象，并指定接收者。
2. 客户端将命令对象传递给调用者。
3. 调用者接收到命令对象后，通过命令对象的接口调用执行命令的方法。
4. 命令对象执行相应的操作，并将请求传递给接收者进行处理。

通过使用命令模式，可以将请求者和接收者解耦，使得请求者不需要了解接收者的细节，同时也可以支持撤销、重做等操作。命令模式还可以方便地扩展和修改命令的执行方式，例如实现命令队列、日志记录等功能。

总结：命令模式通过将请求封装成对象，实现了请求者和接收者之间的解耦，同时提供了灵活的参数化和传递请求的方式。

#### 代码实现

假设我们有一个简单的文本编辑器应用程序，其中包含一些基本的编辑操作，如打开文件、保存文件、剪切文本和粘贴文本等。我们可以使用命令模式来实现这些编辑操作。

首先，我们定义一个通用的命令接口 `Command`，其中包含执行命令的方法 `execute()` 和撤销命令的方法 `undo()`：

```java
public interface Command {
    void execute();
    void undo();
}
```

然后，我们实现具体的命令类来代表不同的编辑操作。例如，我们创建一个打开文件的命令类 `OpenFileCommand`：

```java
public class OpenFileCommand implements Command {
    private TextEditor textEditor;
    private String fileName;

    public OpenFileCommand(TextEditor textEditor, String fileName) {
        this.textEditor = textEditor;
        this.fileName = fileName;
    }

    public void execute() {
        textEditor.openFile(fileName);
    }

    public void undo() {
        textEditor.closeFile();
    }
}
```

类 `OpenFileCommand` 实现了 `Command` 接口，并在 `execute()` 方法中调用 `TextEditor` 对象的 `openFile()` 方法来执行打开文件的操作，在 `undo()` 方法中调用 `closeFile()` 方法来撤销打开文件操作。

接下来，我们定义一个文本编辑器类 `TextEditor`，它作为接收者，并包含了实际的编辑操作方法：

```java
public class TextEditor {
    private String currentFile;

    public void openFile(String fileName) {
        System.out.println("Opening file: " + fileName);
        currentFile = fileName;
    }

    public void closeFile() {
        System.out.println("Closing file: " + currentFile);
        currentFile = null;
    }

    // 其他编辑操作方法...
}
```

最后，我们创建一个调用者类 `Invoker`，它接收命令并执行相应的操作：

```java
public class Invoker {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void executeCommand() {
        command.execute();
    }

    public void undoCommand() {
        command.undo();
    }
}
```

现在，我们可以在客户端中使用命令模式来执行编辑操作：

```java
public class Client {
    public static void main(String[] args) {
        TextEditor textEditor = new TextEditor();
        Invoker invoker = new Invoker();

        // 创建打开文件的命令并执行
        Command openCommand = new OpenFileCommand(textEditor, "sample.txt");
        invoker.setCommand(openCommand);
        invoker.executeCommand();

        // 创建剪切文本的命令并执行
        Command cutCommand = new CutTextCommand(textEditor);
        invoker.setCommand(cutCommand);
        invoker.executeCommand();

        // 撤销剪切命令
        invoker.undoCommand();

        // 其他操作...
    }
}
```

以上示例展示了如何使用命令模式来执行打开文件和剪切文本的操作。客户端通过创建不同的命令对象，并将其传递给调用者来执行相应的操作，实现了命令的封装和解耦。

#### 命令模式和策略模式的区别

策略模式（Strategy Pattern）和命令模式（Command Pattern）是两种常见的设计模式，它们都属于行为型模式，但在目的和使用方式上有一些区别。

1. 目的：
   - 策略模式的目的是在运行时根据不同的情况选择不同的算法或行为，使得这些算法或行为可以互相替换，从而使系统更灵活。策略模式侧重于定义一系列可互换的算法，让客户端可以根据需要选择合适的算法进行使用。
   - ==命令模式的目的是将请求封装成一个对象==，从而可以对请求进行参数化和传递，实现调用操作和请求操作的解耦。命令模式侧重于将请求与具体的接收者解耦，使得发送者和接收者之间没有直接的依赖关系，可以灵活地扩展和变化命令的调用方式。
2. 结构：
   - 策略模式通常由三个角色组成：上下文（Context）、策略接口（Strategy Interface）和具体策略（Concrete Strategies）。上下文对象持有一个策略接口的引用，并通过调用策略接口的方法来执行具体的策略。客户端在运行时可以根据需要选择不同的具体策略。
   - 命令模式通常由四个角色组成：命令（Command）、接收者（Receiver）、调用者（Invoker）和客户端（Client）。命令对象封装了特定的操作和接收者，调用者负责执行命令，而客户端创建命令对象并将其传递给调用者。调用者和接收者之间通过命令对象解耦，可以支持撤销、重做等操作。
3. 使用方式：
   - 策略模式通过定义一系列可互换的策略实现了算法的灵活性。客户端需要了解不同的策略，并在需要时选择合适的策略进行使用。
   - 命令模式通过将请求封装成命令对象实现了调用操作和请求操作的解耦。客户端创建命令对象并将其传递给调用者，调用者可以在不了解具体命令细节的情况下执行命令。

总结起来，策略模式注重算法的灵活性和互换性，客户端在运行时选择合适的策略；而命令模式注重请求的封装和解耦，通过命令对象将请求者和接收者解耦，支持灵活的操作和扩展。

### 11. 原型模式（Prototype Pattern）-具体例子是什么？

Java原型模式（Prototype Pattern）是一种创建型设计模式，其目的是通过复制现有对象来创建新的对象。

#### 使用场景

- 当对象创建的过程比较耗时或者比较复杂，例如需要进行复杂的计算或者涉及到网络请求等操作，可以使用原型模式来避免重复的初始化过程。
- 当需要创建的对象需要和其他对象进行协同工作时，例如需要创建一个包含多个对象的组合对象，可以使用原型模式来复制一个已有的组合对象，然后进行修改来创建新的组合对象。
- 当需要动态地增加或者删除一些对象时，可以使用原型模式来复制一个已有的对象，然后进行修改来创建新的对象。
- 当需要保护对象的复杂状态时，例如当一个对象的创建需要大量的数据初始化时，可以使用原型模式来保护这些数据，避免因为对象的复制而产生意外的副作用。

#### 代码实现

```java
public interface Prototype {
    public Prototype clone();
}
```

```java
public class ConcretePrototype implements Prototype {
    @Override
    public Prototype clone() {
        return new ConcretePrototype();
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        Prototype prototype = new ConcretePrototype();
        Prototype clone = prototype.clone();
    }
}
```

#### 使用小结

1. Java中的`Object`类实现了`Cloneable`接口，这就意味着Java中的任何对象都可以实现原型模式。通过实现`Cloneable`接口，并重写`Object`类中的`clone()`方法，可以实现原型模式。例如 `ArrayList、HashMap `等集合类都实现了`Cloneable` 接口，可以通过复制现有对象来创建新的对象。

   ```java
   ArrayList<Integer> list = new ArrayList<Integer>();
   list.add(1);
   list.add(2);
   System.out.println(list);
   ArrayList<Integer> list2 = (ArrayList<Integer>) list.clone();
   System.out.println(list2);
   list2.add(3);
   System.out.println(list);
   System.out.println(list2);
   ```

   ```
   // 上面程序的输出
   [1, 2]
   [1, 2]
   [1, 2]
   [1, 2, 3]
   ```

   

2. Java中的线程池也是使用了原型模式，线程池中的每个线程都是从原型线程中复制而来，而不是每次创建新的线程。

### 12. 建造者模式（Builder Pattern）

Java建造者模式（Builder Pattern）是一种创建型设计模式，它通过将一个复杂的对象的创建过程分解成多个简单的步骤，并将这些步骤封装到一个Builder对象中，从而可以灵活地创建不同的对象

#### 使用场景

- 当需要创建复杂的对象，并且对象的构建过程包含多个步骤时，可以使用建造者模式
- 当需要创建不同配置的对象时，可以使用建造者模式。
- 当需要创建可变的对象时，可以使用建造者模式。

#### 代码实现

```java
public class User {
    private String name;
    private String email;
    private int age;

    // 防止创建多个User对象
    private User(Builder builder) {
        this.name = builder.name;
        this.email = builder.email;
        this.age = builder.age;
    }

    // 只在调用的时候调用一次
    public static class Builder {
        private String name;
        private String email;
        private int age;

        public Builder setName(String name) {
            this.name = name;
            return this;
        }

        public Builder setEmail(String email) {
            this.email = email;
            return this;
        }

        public Builder setAge(int age) {
            this.age = age;
            return this;
        }

        // 永远保证只创建一次User对象
        public User build() {
            return new User(this);
        }
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        User user = new User.Builder()
                .setName("lzh")
                .setEmail("1@qq.com")
                .setAge(22)
                .build();
    }
}
```



#### 使用小结

1. `StringBuilder` 类就是一个建造者模式的典型应用。它允许使用者逐步构建一个字符串，并最终返回构建好的字符串。

   ```java
   public class StringBuilderExample {
       public static void main(String[] args) {
           StringBuilder stringBuilder = new StringBuilder();
   
           // 添加字符串
           stringBuilder.append("Hello");
   
           // 添加整数
           int num = 10;
           stringBuilder.append(" ").append(num);
   
           // 添加浮点数
           double decimal = 3.14;
           stringBuilder.append(" ").append(decimal);
   
           // 添加布尔值
           boolean flag = true;
           stringBuilder.append(" ").append(flag);
   
           // 添加字符数组
           char[] charArray = {' ', 'W', 'o', 'r', 'l', 'd'};
           stringBuilder.append(charArray);
   
           // 插入字符串
           stringBuilder.insert(6, "Awesome");
   
           // 删除字符串
           stringBuilder.delete(0, 5);
   
           // 替换字符串
           stringBuilder.replace(0, 5, "Hi");
   
           // 反转字符串
           stringBuilder.reverse();
   
           // 输出结果
           System.out.println(stringBuilder.toString());
       }
   }
   ```

   这个例子演示了一些常见的`StringBuilder`操作，包括添加字符串、整数、浮点数、布尔值和字符数组，插入字符串，删除字符串，替换字符串以及反转字符串。最后，通过调用`toString()`方法将`StringBuilder`对象转换为字符串并打印输出结果。

   请注意，`StringBuilder`类是可变的，可以高效地进行字符串的操作和修改，而不会创建新的字符串对象。这使得它在需要频繁修改字符串内容的情况下比较实用。

2. `Guava` 库是一个常用的Java库，其中的 `ImmutableList.Builder` 类也是一个典型的建造者模式应用。它允许使用者逐步构建一个不可变的列表，并最终返回构建好的列表。

  总之，建造者模式在Java中的应用非常广泛，特别是在构建复杂对象时，它可以使构建过程更加灵活、可扩展和可维护。

### 13. 桥接模式（Bridge Pattern）

Java桥接模式（Bridge Pattern）是一种结构型设计模式，它将一个对象的抽象部分与它的实现部分分离，使它们可以独立地变化。桥接模式的目的是将抽象与实现解耦，从而实现系统的灵活性和可扩展性。

#### 使用场景

- 当一个类存在多个实现版本时，可以使用桥接模式将其分离开来，从而使得这些实现版本可以独立地变化。
- 当需要将一个抽象部分与它的实现部分分离开来，以便它们可以独立地进行修改和扩展时，可以使用桥接模式。
- 当需要在抽象类中定义抽象方法，以便在不同的实现类中实现具体的行为时，可以使用桥接模式。
- 当需要在运行时动态地改变一个对象的实现时，可以使用桥接模式。
- 当需要将一个大类拆分成多个独立的层级时，可以使用桥接模式

#### 代码实现

假设有一个图形绘制应用程序，它支持绘制不同颜色的图形。图形可以是矩形、圆形等等。我们可以使用桥接模式来将颜色和图形分离开来。

首先，我们定义一个颜色接口 Color 和它的两个实现类 Red 和 Blue

```java
public interface Color {
    public void applyColor();
}
```

```java
public class Red implements Color {
    @Override
    public void applyColor() {
        System.out.println("红色");
    }
}
```

```java
public class Blue implements Color {
    @Override
    public void applyColor() {
        System.out.println("蓝色");
    }
}
```

```java
public abstract class Shape {
    protected Color color;

    public Shape(Color color) {
        this.color = color;
    }

    public abstract void draw();
}
```

```java
public class Circle extends Shape {

    public Circle(Color color) {
        super(color);
    }

    @Override
    public void draw() {
        color.applyColor();
        System.out.println("画圆圈");
    }
}
```

```java
public class Rectangle extends Shape {

    public Rectangle(Color color) {
        super(color);
    }

    @Override
    public void draw() {
        color.applyColor();
        System.out.println("画矩形");
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        Color red = new Red();
        Blue blue = new Blue();

        Shape circle = new Circle(red);
        Shape rectangle = new Rectangle(blue);

        circle.draw();
        rectangle.draw();
    }
}
```

#### 使用小结

一个经典的桥接模式例子是 JDBC API。在 JDBC API 中，`DriverManager` 充当桥接模式中的抽象部分，它负责管理多个 JDBC 驱动程序的实现部分。开发人员可以通过 `DriverManager` 类来连接数据库，而无需了解底层数据库驱动程序的具体实现。

### 14. 过滤器模式（Filter Pattern）

Java 过滤器模式（Filter Pattern）是一种结构型设计模式，它允许你使用不同的标准来过滤一组对象，从而去除其中不需要的元素。

#### 使用场景

- 当你需要从一个集合中过滤出一部分元素时。
- 当你需要根据不同的标准来过滤同一个集合时。
- 当你需要在一个集合中根据不同标准来组合过滤器时。

#### 代码实现

假设有一个 `Person` 类，包含姓名、年龄、性别等属性，我们可以定义一个过滤器接口 `Filter`，其中包含一个过滤方法 `filter`，用于过滤出符合某种条件的人。

```java
public interface Filter {
    List<Person> filter(List<Person> persons);
}
```

```java
public class MaleFilter implements Filter {
    @Override
    public List<Person> filter(List<Person> persons) {
        return persons.stream()
                .filter(person -> person.getSex().equals("MALE"))
                .collect(Collectors.toList());
    }
}
```

```java
public class AgeFilter implements Filter {
    @Override
    public List<Person> filter(List<Person> persons) {
        return persons.stream()
                .filter(person -> person.getAge() > 18)
                .collect(Collectors.toList());
    }
}
```

```java
public class FilterChain implements Filter {

    private List<Filter> filters;

    public FilterChain(List<Filter> filters) {
        this.filters = filters;
    }

    @Override
    public List<Person> filter(List<Person> persons) {
        List<Person> result = persons;
        for (Filter filter : filters) {
            result = filter.filter(result);
        }
        return result;
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        List<Person> persons = new ArrayList<>();
        persons.add(new Person("Tom", 20, "MALE"));
        persons.add(new Person("Lucy", 19, "FEMALE"));
        persons.add(new Person("John", 17, "MALE"));
        persons.add(new Person("Lily", 21, "FEMALE"));

        Filter maleFilter = new MaleFilter();
        Filter ageFilter = new AgeFilter();
        FilterChain filterChain = new FilterChain(Arrays.asList(maleFilter, ageFilter));

        List<Person> males = maleFilter.filter(persons);
        System.out.println("males:");
        males.forEach(System.out::println);

        List<Person> age18s = ageFilter.filter(persons);
        System.out.println("18以上:");
        age18s.forEach(System.out::println);

        List<Person> res = filterChain.filter(persons);
        System.out.println("18以上的males:");
        res.forEach(System.out::println);
    }
}
```

#### 使用小结

滤器模式的核心是 `Filter` 接口，该接口包含了一个方法 `filter()`，用于对对象进行过滤。根据具体实现，filter() 方法可以接受一个对象作为参数，然后根据特定的标准判断该对象是否应该被过滤掉。过滤器模式在Java中可以应用于许多场景，例如：

1. Web开发中，对HTTP请求进行过滤，例如身份验证，日志记录等。
2. 在Spring框架中，过滤器可以用于过滤请求并对请求进行预处理，例如对请求参数进行验证等。
3. Java 中的 `Stream API `提供了丰富的过滤器方法,如 `filter()、distinct()、map() `等

过滤器模式可以用于任何需要对数据进行过滤和处理的场景。

### 15. 组合模式（Composite Pattern）

组合模式是一种结构型设计模式，它允许将对象组合成树形结构，以表示“部分-整体”的层次关系。组合模式可以让客户端使用统一的方式处理单个对象和组合对象，从而简化了客户端的代码。

#### 使用场景

1. 当需要表示一个对象的部分-整体层次结构时，可以使用组合模式。例如，可以使用组合模式来表示一个文件夹，它包含多个文件和其他文件夹。
2. 当客户端代码需要统一地处理单个对象和组合对象时，可以使用组合模式。这样客户端代码可以使用相同的代码来处理单个对象和组合对象，而不需要进行特判。
3. 当需要对树形结构进行递归遍历时，可以使用组合模式。组合模式可以让代码更加简洁，而且可以轻松地遍历整个树形结构
4. 当需要动态地添加或删除树形结构中的子节点时，可以使用组合模式。组合模式可以让你方便地添加或删除子节点，而且不会影响其他节点的行

#### 代码实现

以下是另一个使用Java组合模式的例子，它表示一个文件系统：

```java
public class FileSystem {
    private String name;
    private boolean isFile;
    private List<FileSystem> children = new ArrayList<>();


    public FileSystem(String name, boolean isFile) {
        this.name = name;
        this.isFile = isFile;
    }

    public void add(FileSystem file) {
        children.add(file);
    }

    public void remove(FileSystem file) {
        children.remove(file);
    }

    public void display(int depth) {
        System.out.println("-".repeat(depth) + name);

        for (FileSystem file : children) {
            file.display(depth + 2);
        }
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        FileSystem root = new FileSystem("C:", false);
        FileSystem windowsFolder = new FileSystem("Windows", false);
        FileSystem programFilesFolder = new FileSystem("Program Files", false);
        FileSystem notepadFile = new FileSystem("notepad.exe", true);
        FileSystem javaFolder = new FileSystem("Java", false);
        FileSystem eclipseFolder = new FileSystem("Eclipse", false);
        FileSystem eclipseExeFile = new FileSystem("eclipse.exe", true);

        root.add(windowsFolder);
        root.add(programFilesFolder);
        programFilesFolder.add(notepadFile);
        programFilesFolder.add(javaFolder);
        windowsFolder.add(eclipseFolder);
        eclipseFolder.add(eclipseExeFile);

        root.display(2);
    }
}
```

在这个例子中，`FileSystem`表示一个文件系统中的文件或文件夹，它有一个`name`属性和一个`isFile`属性，用于判断它是文件还是文件夹。`add`和`remove`方法用于添加或删除子节点，`display`方法用于递归地打印整个文件系统。

  在`main`方法中，我们创建了一个`C:`盘的文件系统，并添加了`Windows`文件夹、`Program Files`文件夹、`notepad.exe`文件、`Java`文件夹、`Eclipse`文件夹和`eclipse.exe`文件。我们将这些文件和文件夹按照层次结构组织起来，方便用户查看整个文件系统。

#### 使用小结

组合模式可以用于处理具有树形结构的对象集合。比如组织架构图、文件系统、图形场景图等。使用组合模式可以方便地组合对象，以实现复杂的功能。

### 16. 外观模式（Facade Pattern）

外观模式是一种结构型设计模式，它提供了一个简单的接口，隐藏了一组复杂的子系统的复杂性，使得客户端可以更容易地使用这个子系统。

外观模式的核心思想是通过提供一个简化的接口，将系统的复杂性封装起来，从而降低系统的耦合性，并使得系统更易于维护和扩展。

#### 使用场景

1. 系统中包含多个模块，每个模块都有自己的接口和实现，需要对外提供一个统一的接口
2. 系统中存在多个复杂的对象或类，需要对外提供简单的接口
3. 需要解耦系统的各个组件，使得它们可以独立变化
4. 需要隔离系统的变化，使得系统的不同模块可以独立变化

#### 代码实现

一个常见的外观模式的例子是电脑开机过程。在电脑开机的过程中，有许多子系统需要被初始化，例如 CPU、内存、硬盘等等。如果每个子系统都要直接与客户端进行交互，那么客户端的代码会非常复杂。

使用外观模式可以将所有子系统的初始化过程封装到一个简单的接口中，从而使得客户端只需要与外观对象交互，就可以完成所有的初始化过程。

```java
public class CPU {
    public void start() {
        System.out.println("CPU正在启动...");
    }
}
```

```java
public class Screen {
    public void start() {
        System.out.println("Screen正在启动...");
    }
}
```

```java
public class Computer {
    private CPU cpu;
    private Screen screen;

    public Computer() {
        this.cpu = new CPU();
        this.screen = new Screen();
    }

    public void start() {
        System.out.println("电脑正在启动...");
        cpu.start();
        screen.start();
        System.out.println("电脑启动完成。");
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        Computer computer = new Computer();
        computer.start();
    }
}
```

在这个例子中，`CPU`、`Memory`、`HardDrive` 分别代表电脑开机过程中的 CPU、内存、硬盘子系统，`Computer` 则是外观类，它封装了所有子系统的初始化过程，提供了一个简单的 `start` 方法。客户端只需要与 `Computer` 对象交互即可完成电脑的开机过程，而不需要了解每个子系统的实现细节。

#### 使用小结

在Java中，外观模式经常被用于封装底层的复杂子系统，提供一个更加简单、易于使用的接口给上层模块调用。

- `JDBC`是Java中访问关系型数据库的标准接口，它封装了许多与数据库操作相关的底层细节，使得程序员可以通过简单的接口来进行数据库操作。`JDBC`的`Connection、Statement、ResultSet`等接口和类就是外观模式的典型应用，它们提供了一个简单的接口，封装了与数据库底层的交互细节。
- `Spring`其中的许多组件都使用了外观模式来隐藏底层的复杂性。例如，`Spring`中的`AOP`（面向切面编程）模块提供了一个简单的接口，封装了底层的动态代理、拦截器等复杂细节；`Spring`中的`JDBC`模块也提供了一个简单的接口，封装了与数据库操作相关的底层细节。
- Java网络编程中的`Socket`类和`ServerSocket`类也是外观模式的典型应用，它们提供了一个简单的接口，封装了与网络通信相关的底层细节。
- Java虚拟机中的类加载器、内存管理、线程调度等子系统都是外观模式的典型应用，它们提供了一个简单的接口，封装了与虚拟机底层相关的复杂细节。

### 17. 享元模式（Flyweight Pattern）

享元模式是一种结构型设计模式，它通过共享对象来减少内存占用和提高系统性能。享元模式适用于大量细粒度的对象，这些对象具有相似的属性，而且这些属性可以被共享。

在享元模式中，我们将对象分为两种：

- 内部状态指对象共享的部分，可以被多个对象共享；
- 外部状态则指对象独有的部分，不能被共享。

  通过将内部状态抽取出来，我们可以减少系统中需要创建的对象数量，从而降低内存消耗。

#### 使用场景

1. 当一个应用程序需要创建大量的相似对象时，使用享元模式可以减少内存占用和提高系统性能
2. 当一个对象的状态可以被拆分为内部状态和外部状态时，使用享元模式可以将内部状态共享，从而减少对象数量和内存消耗。
3. 当一个应用程序需要使用缓存来提高性能时，可以使用享元模式来实现缓存功能，从而提高系统性能。

#### 代码实现

使用享元模式实现一个简单的字符串存储库，它可以存储大量的字符串，同时尽可能节省内存。

首先定义一个 `Flyweight` 接口，它表示共享的字符串对象。具体的字符串对象将实现这个接口。

```java
public interface Flyweight {
    void print(String str);
}
```

```java
public class ConcreteFlyweight implements Flyweight {
    private String str;
    private int count;

    public ConcreteFlyweight(String str) {
        this.str = str;
        this.count = 0;
    }

    public String getStr() {
        return str;
    }

    public int getCount() {
        return count;
    }

    @Override
    public void print(String str) {
        System.out.println("当前字符串是 " + str);
        this.count ++;
    }
}
```

```java
public class FlyweightFactory {
    public static final Map<String, Flyweight> flyweightMap = new HashMap<>();

    public static Flyweight getFlyweight(String str) {
        Flyweight flyweight = flyweightMap.get(str);
        if (flyweight == null) {
            flyweight = new ConcreteFlyweight(str);
            flyweightMap.put(str, flyweight);
        }
        return flyweight;
    }
}
```

```java
public class demo {
    public static void main(String[] args) {
        String[] strings = {"hello", "world", "hello", "java", "world"};

        for (String str : strings) {
            Flyweight flyweight = FlyweightFactory.getFlyweight(str);
            flyweight.print(str);
        }

        System.out.println("Flyweight count: " + FlyweightFactory.flyweightMap.size());
        for (Flyweight flyweight : FlyweightFactory.flyweightMap.values()) {
            System.out.println("String: " + ((ConcreteFlyweight) flyweight).getStr() +
                    ", Count: " + ((ConcreteFlyweight) flyweight).getCount());
        }
    }
}
```

#### 使用小结

使用享元模式可以显著降低内存消耗并提高系统的性能。比如：

- Java 中的字符串池是一个存储字符串对象的池子，可以共享字符串对象，而不是为每个字符串都创建一个新的实例。
- Java 中的数据库连接池可以缓存一些已经建立好的数据库连接，当需要使用数据库时，可以直接从连接池中获取连接，而不需要每次都创建一个新的连接。这样可以大大提高数据库的访问效率和性能。

### 18. 代理模式（Proxy Pattern）

代理模式是一种结构型设计模式，它为其他对象提供一个代理以控制对该对象的访问。代理是一个具有与原始对象相同的接口的对象，客户端不必知道它与原始对象交互的方式。代理可以拦截对原始对象的访问，并在某些情况下将请求传递给原始对象。

代理模式有两种主要形式:

- 静态代理：在编译时就已经确定了代理类和被代理类之间的关系，通常需要为每个被代理类都编写一个对应的代理类，并实现相同的接口。 静态代理的优点是简单易懂，缺点是不灵活，代码冗余。
- 动态代理：在运行时动态生成代理对象，并根据反射机制调用被代理类的方法。 动态代理可以使用`Java`原生API或者第三方框架来实现，如`JDK Proxy、CGLIB、`等。 动态代理的优点是灵活高效，缺点是复杂难懂。

#### 使用场景

  代理模式的主要目的是通过代理对象来控制对原始对象的访问，并提供一些额外的功能。比如：

- 当我们想要隐藏某个类时，可以为其提供代理类。例如，我们想要访问一个远程对象，但是不想暴露其网络细节，就可以使用代理类来封装网络通信
- 当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现。例如，我们想要限制某些用户对某些方法的访问，就可以在代理类中进行权限检查。
- 当我们要扩展某个类的某个功能时，可以使用代理模式。 例如，我们想要在调用某个方法之前或之后添加日志、缓存、事务等功能，就可以在代理类中实现

#### 代码实现

##### 静态代理

一个简单的 Java 静态代理例子，它模拟了一个银行账户的操作：

```java
public interface Account {
    void deposit(double amount);
    void withdraw(double amount);
}
```

```java
public class BankAccount implements Account {
    private double balance;

    public BankAccount(double balance) {
        this.balance = balance;
    }

    @Override
    public void deposit(double amount) {
        balance += amount;
        System.out.println("存了：" + amount + "， 余额是：" + balance);
    }

    @Override
    public void withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
            System.out.println("取走：" + amount + "，余额：" + balance);
        } else {
            System.out.println("余额不足：" + balance);
        }
    }
}
```

```java
public class AccountProxy implements Account {
    private BankAccount bankAccount;

    public AccountProxy(BankAccount bankAccount) {
        this.bankAccount = bankAccount;
    }

    @Override
    public void deposit(double amount) {
        bankAccount.deposit(amount);
    }

    @Override
    public void withdraw(double amount) {
        bankAccount.withdraw(amount);
    }

}
```

```java
public class demo {
    public static void main(String[] args) {
        BankAccount bankAccount = new BankAccount(100);
        Account accountProxy = new AccountProxy(bankAccount);

        accountProxy.deposit(100);
        accountProxy.withdraw(150);
        accountProxy.withdraw(100);
    }
}
```

在上面的例子中，`BankAccount` 是账户接口 `Account` 的实现类，它负责实际的存款和取款操作。而 `AccountProxy` 则是账户代理类，它实现了账户接口，并在其中持有一个 `BankAccount` 实例。在 `AccountProxy` 的 `deposit` 和 `withdraw` 方法中，它会将操作转发给 `BankAc`。

在 `Main` 方法中，客户端使用代理来执行操作，而无需直接操作实际对象。

##### 动态代理

使用 Java 内置的 `java.lang.reflect.Proxy` 类来创建动态代理

```java
public interface Account {
    void deposit(double amount);
    void withdraw(double amount);
}
```

```java
public class BankAccount implements Account {
    private double balance;

    public BankAccount(double balance) {
        this.balance = balance;
    }

    @Override
    public void deposit(double amount) {
        balance += amount;
        System.out.println("存了：" + amount + "， 余额是：" + balance);
    }

    @Override
    public void withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
            System.out.println("取走：" + amount + "，余额：" + balance);
        } else {
            System.out.println("余额不足：" + balance);
        }
    }
}
```

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class AccountHandler implements InvocationHandler {
    private BankAccount bankAccount;

    public AccountHandler(BankAccount bankAccount) {
        this.bankAccount = bankAccount;
    }


    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.getName().equals("deposit")) {
            System.out.println("---存钱之前的操作---");
            System.out.println(".sdassdadas adasdadasd ");
            method.invoke(bankAccount, args);
            System.out.println("---存钱之后的操作---");
            System.out.println(".sdassdadas adasdadasd.sdassdadas adasdadasd.sdassdadas adasdadasd ");
        } else if (method.getName().equals("withdraw")) {
            System.out.println("---取钱之前的操作---");
            method.invoke(bankAccount, args);
            System.out.println("---取钱之后的操作---");
        }
        return null;
    }
}
```

```java
import java.lang.reflect.Proxy;

public class demo {
    public static void main(String[] args) {
        // 创建一个银行账户对象
        BankAccount bankAccount = new BankAccount(100.0);
        // 创建一个账户代理实例
        AccountHandler accountHandler = new AccountHandler(bankAccount);

        // 使用动态代理创建一个代理对象
        Account proxy = (Account) Proxy.newProxyInstance(
                accountHandler.getClass().getClassLoader(),  // 用来做代理的类
                new Class<?>[] { Account.class },  // 代理类需要实现的接口数组
                accountHandler  // 实现了 InvocationHandler 接口的处理器对象，用于在方法调用前后执行额外逻辑。
        );

        proxy.deposit(100);
        proxy.withdraw(150);
        proxy.withdraw(100);

    }
}
```

`BankAccount` 和 `AccountProxy` 类的定义与静态代理例子相同。不同之处在于，我们创建了一个实现了 `InvocationHandler` 接口的 `AccountProxy` 类，它的 `invoke` 方法用来处理代理对象的方法调用。在 `invoke` 方法中，我们可以根据被调用的方法名称来添加一些额外的功能。在这个例子中，我们为 `deposit` 和 `withdraw` 方法添加了前置和后置操作。

在 `Main` 类中，创建了一个银行账户实例，并将它传递给了一个账户代理实例。然后，我们使用 `Proxy.newProxyInstance` 方法创建一个动态代理对象，该对象实现了 `Account` 接口，并在其方法调用时会调用 `AccountProxy` 的 `invoke` 方法。最后，我们使用代理对象进行存款和取款操作。

#### 使用小结

代理模式在`Java`中的应用比较广泛，比如`Spring`的`AOP`实现、远程`RPC`调用等。代理模式可以在不修改原始接口的情况下，对目标对象进行增强或者替换

#### 代理模式和适配器模式的区别

代理模式（Proxy Pattern）和适配器模式（Adapter Pattern）是两种常见的设计模式，它们具有不同的作用和使用场景。

代理模式用于提供一个代理对象来控制对另一个对象的访问。它主要用于在不改变原始对象的情况下，增加额外的功能或限制对原始对象的访问。代理模式的关键是代理对象和原始对象实现相同的接口，使得客户端可以通过代理对象间接地访问原始对象。代理模式可以分为静态代理和动态代理两种形式。

适配器模式用于将一个类的接口转换为客户端所期望的另一个接口。它主要用于解决两个已有接口之间不兼容的问题，使得原本因为接口不匹配而无法工作的类能够协同工作。适配器模式通过创建一个适配器类，将原始接口转换为目标接口，从而使得客户端可以通过适配器对象使用原始对象。适配器模式可以分为类适配器和对象适配器两种形式。

总结来说，代理模式用于在访问控制的基础上增加功能或限制访问，而适配器模式用于解决接口不兼容的问题。代理模式通常与原始对象实现相同的接口，而适配器模式需要将原始接口转换为目标接口。

#### 动态代理模式和装饰器模式的区别

装饰器模式和动态代理模式都是常见的用于在现有代码上加入额外功能的设计模式，但它们的实现方式和应用场景有一些区别。

装饰器模式（Decorator Pattern）是一种结构型设计模式，用于动态地给对象添加新的功能，而无需修改其原始类。它通过创建一个包装器类，该类包含一个原始对象的实例，并提供与原始对象相同的接口。装饰器类可以在不改变原始对象的情况下，通过在调用原始对象的方法前后添加额外的逻辑，来增强或修改原始对象的行为。这种方式实现了代码的灵活性和可扩展性，允许动态地组合多个装饰器。

动态代理模式（Dynamic Proxy Pattern）是一种行为型设计模式，它允许在运行时创建一个代理对象，该对象可以拦截对真实对象的访问并执行特定的操作。代理对象和真实对象实现相同的接口，这样客户端无需知道代理对象的存在。通过代理对象，可以在调用真实对象的方法前后进行额外的处理，例如记录日志、进行性能监测、实现懒加载等。代理对象可以完全控制对真实对象的访问，并可以选择性地转发或拦截方法调用。

区别如下：

1. 目的不同：装饰器模式的主要目的是为了在不修改原始类的情况下增加新的功能，而动态代理模式的主要目的是控制对真实对象的访问，并在访问前后执行一些操作。
2. 抽象程度不同：装饰器模式通常通过创建装饰器类来实现，这个类与原始对象实现相同的接口，并持有一个原始对象的实例。而动态代理模式是通过创建代理对象来实现，代理对象实现与真实对象相同的接口，并持有一个真实对象的引用。
3. 灵活性不同：装饰器模式可以在运行时动态地添加多个装饰器，以实现不同的功能组合。而动态代理模式在创建代理对象时，需要指定一个特定的处理程序，其行为是固定的，难以动态地修改代理对象的行为。
4. 使用场景不同：装饰器模式适用于需要在不修改原始类代码的情况下，动态地增加功能的场景。动态代理模式适用于需要在访问真实对象之前或之后执行额外操作的场景，例如实现日志记录、性能监测、事务管理等。

总之，装饰器模式主要关注在不改变原始类结构的情况下增加新功能，而动态代理模式主要关注在控制对真实对象的访问并执行额外操作。