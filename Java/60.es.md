## Elasticsearch

Elasticsearch是一个开源的分布式搜索和分析引擎，主要用于处理大规模数据的搜索、分析和存储。它可以快速地搜索和分析大量数据，支持实时搜索和聚合分析，具有高可用性和可扩展性。

与MySQL相比，Elasticsearch具有以下几个区别：

1. 数据结构：MySQL是关系型数据库，需要定义表和列，而Elasticsearch是==文档型数据库==，数据以文档的形式存储，可以自由定义字段。

2. 搜索方式：MySQL的搜索方式是基于SQL语句的查询，而Elasticsearch的搜索方式是基于全文搜索和过滤器的查询。

3. 扩展性：MySQL的扩展性有限，需要对数据库进行分库分表等操作，而Elasticsearch可以通过添加节点来实现水平扩展。

为什么要使用Elasticsearch：

1. 处理大规模数据：Elasticsearch能够处理海量的数据，支持实时搜索和聚合分析。

2. 实时性：Elasticsearch具有实时性，可以在数据更新后立即进行搜索和分析。

3. 可扩展性：Elasticsearch可以通过添加节点来实现水平扩展，支持集群部署。

4. 全文搜索：Elasticsearch支持全文搜索和过滤器查询，能够更加准确地匹配搜索关键字。

5. 高可用性：Elasticsearch具有高可用性，支持数据备份和恢复，可以保障数据的安全性和可靠性。

### 全文搜索和过滤器查询

全文搜索是指在文本数据中进行关键字搜索的方式。在Elasticsearch中，全文搜索是指对文档中的所有字段进行搜索匹配的方式，而不是只针对特定字段进行搜索。全文搜索可以使用各种查询方式，包括匹配查询、模糊查询、正则表达式查询等。

过滤器查询是指使用过滤器来对数据进行筛选的方式。在Elasticsearch中，过滤器查询可以对文档中的字段进行筛选，可以使用各种过滤器，包括范围过滤器、存在过滤器、缺失过滤器等。过滤器查询可以提高查询效率，因为它可以在搜索结果之前对数据进行过滤，从而减少搜索的数据量。

全文搜索和过滤器查询是Elasticsearch中两种常用的查询方式，它们可以组合使用，从而实现更加精确和高效的搜索和筛选。

### endpoint

Elasticsearch的endpoint是指与Elasticsearch进行交互的API接口地址。Elasticsearch提供了多种API接口，可以通过不同的endpoint来访问这些接口，进行搜索、索引、删除、更新等操作。

以下是一些常用的Elasticsearch endpoint：

1. _search：用于执行搜索操作，可以使用各种查询方式和过滤器查询。

2. _index：用于创建、更新和删除索引，可以指定索引的名称和设置。

3. _doc：用于创建、更新和删除文档，可以指定文档的ID和内容。

4. _bulk：用于批量操作文档，可以一次性处理多个文档。

5. _cat：用于查看集群、节点、索引等的状态信息。

6. _cluster：用于管理集群的设置和状态信息。

7. _nodes：用于查看节点的状态信息和统计数据。

8. _aliases：用于管理索引别名，可以创建、更新和删除别名。

以上是一些常用的Elasticsearch endpoint，可以通过这些endpoint来访问Elasticsearch的API接口，进行各种操作。

### enpoint使用示例

以下是一些常用的Elasticsearch endpoint的使用实例：

1. _search：执行搜索操作

```
POST /my_index/_search
{
  "query": {
    "match": {
      "title": "Elasticsearch"
    }
  }
}
```

该请求将在名为my_index的索引中搜索title字段包含“Elasticsearch”关键字的文档。

2. _index：创建索引

```
PUT /my_index
{
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 0
  }
}
```

该请求将创建一个名为my_index的索引，并设置它的分片数为1，副本数为0。

3. _doc：创建文档

```
POST /my_index/_doc
{
  "title": "Elasticsearch入门",
  "content": "这是一篇Elasticsearch入门的文章"
}
```

该请求将在名为my_index的索引中创建一个新的文档，并设置它的title和content字段。

4. _bulk：批量操作文档

```
POST /my_index/_bulk
{ "index": { "_id": "1" } }
{ "title": "Elasticsearch入门", "content": "这是一篇Elasticsearch入门的文章" }
{ "delete": { "_id": "2" } }
```

该请求将一次性创建一个新文档和删除一个文档，其中新文档的ID为1，内容为title和content字段，要删除的文档ID为2。

5. _cat：查看状态信息

```
GET /_cat/indices?v
```

该请求将列出所有索引的状态信息，包括索引名称、分片数、文档数等。

6. _cluster：管理集群设置

```
PUT /_cluster/settings
{
  "transient": {
    "cluster.routing.allocation.enable": "all"
  }
}
```

该请求将设置集群的路由分配策略为“all”，即所有节点都可以分配分片。

以上是一些常用的Elasticsearch endpoint的使用实例，可以通过这些endpoint来访问Elasticsearch的API接口，进行各种操作。

### 倒排索引

倒排索引（Inverted Index）是一种数据结构，用于快速查找文档中包含某个单词的位置。它将每个单词映射到包含该单词的文档列表中，以便可以快速地找到包含特定单词的文档。

倒排索引通常用于搜索引擎中，以便用户可以快速地找到包含特定关键词的文档。当用户在搜索引擎中输入关键词时，搜索引擎会使用倒排索引来查找包含关键词的文档，并将这些文档按照相关性排序后返回给用户。

倒排索引的优点是可以快速地查找包含特定单词的文档，缺点是需要占用较大的存储空间，因为需要存储每个单词出现的位置。

### FST

FST（Finite State Transducer）是一种有限状态转换器，是一种自动机，用于在计算机科学中进行字符串匹配和文本处理。它可以将输入字符串映射到输出字符串，也可以将输入字符串映射到状态序列，或者将状态序列映射到输出字符串。

FST通常用于自然语言处理、语音识别、机器翻译、信息检索等领域。它可以用于实现自动化的文本转换、词法分析、语法分析、文本分类等任务。

FST的基本思想是将输入字符串转换为状态序列，然后根据状态序列执行某些操作（如输出字符串）。FST由状态、转移和输出组成，其中状态表示自动机的当前状态，转移表示从一个状态到另一个状态的转换，输出表示从一个状态到另一个状态的转换所对应的输出字符串。

FST的优点是可以高效地处理大量的文本数据，缺点是需要耗费大量的计算资源和存储空间，因为需要存储状态、转移和输出。

**例子**

一个简单的FST例子是将英语单词的复数形式转换为单数形式。假设我们有一个FST，输入是一个英语单词的复数形式，输出是该单词的单数形式。

例如，输入单词“cats”会被转换为输出单词“cat”，输入单词“dogs”会被转换为输出单词“dog”。这个FST可以通过以下步骤实现：

1. 定义状态：FST的状态表示当前处理的字符位置和单词的复数形式是否已经处理完。我们可以定义三种状态：开始状态、中间状态和结束状态。

2. 定义转移：FST的转移表示从一个状态到另一个状态的转换。我们可以定义以下转移：

   a. 从开始状态到中间状态，如果输入字符是一个辅音字母（如c、d、g等）。

   b. 从开始状态到中间状态，如果输入字符是一个元音字母（如a、e、i等）。

   c. 从中间状态到中间状态，如果输入字符是一个辅音字母。

   d. 从中间状态到中间状态，如果输入字符是一个元音字母。

   e. 从中间状态到结束状态，如果输入字符是字母s。

3. 定义输出：FST的输出表示从一个状态到另一个状态的转换所对应的输出字符串。在这个例子中，输出是单数形式的单词。我们可以定义以下输出：

   a. 从开始状态到中间状态，不输出任何字符。

   b. 从中间状态到中间状态，不输出任何字符。

   c. 从中间状态到结束状态，删除最后一个字符（即字母s）。

这样，当输入一个英语单词的复数形式时，FST会按照以上步骤进行转换，最终输出该单词的单数形式。

### BKD-Tree

BKD-Tree（Bounded Box K-Dimensional Tree）是一种用于高维空间数据索引的树形数据结构。它是KD-Tree（K-Dimensional Tree）的一种扩展，能够更好地处理高维数据。

BKD-Tree的基本思想是将数据点递归地划分到不同的子空间中，并将子空间存储在树的节点中。与KD-Tree不同的是，BKD-Tree在每个节点中存储一个有界框（bounding box），用于表示该节点所包含的子空间的范围。这样可以避免在高维空间中出现维度灾难的问题，从而提高了查询效率。

BKD-Tree的构建过程与KD-Tree类似，也是通过递归地划分数据点来构建树形结构。不同之处在于，BKD-Tree在划分数据点时，会选择一个方差最大的维度进行划分，以保证每个子空间的大小相对均衡。

BKD-Tree在高维数据索引中具有很好的性能，能够快速地进行范围查询、最近邻查询等操作。但是，由于需要存储每个节点的有界框，BKD-Tree的存储空间开销较大，因此在处理大规模数据时可能会面临存储空间不足的问题。

### es查询模型



### es索引设计



### es的字段存储

#### 行存和列存

这句话主要是在讨论 Elasticsearch（简称 ES）中的数据存储方式。在 ES 中，除了使用索引来加速查询之外，还提供了两种额外的数据存储策略：行存（stored fields，_source）和列存（doc_value）。

1. **行存（Stored Fields, _source）**：

* 行存是指将文档的原始字段值存储起来。当你执行某些查询时，ES 可以直接从行存中获取整个文档的数据，而无需重新从索引中解析。
* `_source` 字段通常默认包含所有字段，但你也可以选择只存储特定的字段。
* 行存对于需要频繁获取整个文档内容的场景非常有用，例如在搜索结果展示中。

2. **列存（Doc Values）**：

* 列存是针对特定字段的一种优化存储方式，主要用于加速某些类型的查询，如排序、聚合等。
* 在列存中，每个字段的所有值都被存储在一个连续的内存区域或磁盘块中，这使得对这些值的读取和比较变得非常高效。
* 列存不存储字段的原始文本值，而是存储经过处理的、适合快速访问的值。

3. **存储占比与开关接口**：

* 行存和列存在 ES 中的存储占比大致相当，各占约一半的存储空间。它们是用户数据存储的主要部分。
* ES 提供了 API 接口，允许用户根据需要开启或关闭行存和列存功能。这为用户提供了灵活的存储管理选项，可以根据实际业务需求和性能考虑进行调整。

总之，Elasticsearch 通过结合索引、行存（_source）和列存（doc_value）等多种存储策略，实现了高效且灵活的数据检索和管理能力。

#### 行存列存示例

假设我们有一个在线书店的应用，其中包含了大量的书籍信息，每本书都有标题、作者、出版日期、价格等字段。我们希望能够在用户搜索书籍时快速返回相关书籍的详细信息，并且能够对书籍的价格进行排序。

在这个场景中，我们可以使用 Elasticsearch 来存储和管理书籍信息。以下是使用行存和列存的示例：

1. **索引创建**：首先，我们需要创建一个索引来存储书籍信息。在创建索引时，我们可以指定字段的类型和分析器，以便更好地支持搜索。

```json
PUT /books
{
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "standard"
      },
      "author": {
        "type": "keyword"
      },
      "publish_date": {
        "type": "date"
      },
      "price": {
        "type": "float"
      }
    }
  }
}
```

2. **行存（_source）**：默认情况下，Elasticsearch 会将整个文档的原始字段值存储在 `_source` 字段中。这意味着当我们查询书籍信息时，可以直接获取到完整的文档内容。这对于需要展示书籍详细信息的场景非常有用。

```json
GET /books/_search
{
  "query": {
    "match": {
      "title": "Elasticsearch"
    }
  }
}
```

上述查询将返回包含完整书籍信息的文档，包括标题、作者、出版日期和价格等字段。

3. **列存（Doc Values）**：为了加速对价格的排序操作，我们可以使用列存。在创建索引时，我们可以为 `price` 字段启用列存。

```json
PUT /books
{
  "mappings": {
    "properties": {
      ...
      "price": {
        "type": "float",
        "doc_values": true
      }
    }
  }
}
```

现在，当我们执行基于价格的排序操作时，Elasticsearch 将使用列存来提高性能。

```json
GET /books/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "price": {
        "order": "asc"
      }
    }
  ]
}
```

通过结合行存和列存，我们可以在满足搜索需求的同时，提高查询性能和存储效率。在实际应用中，我们可以根据业务需求和性能要求灵活地调整这些存储策略。

### es索引生命周期

在ES中，索引数据的自动滚动和过期是两种管理索引数据的机制。

自动滚动：当一个索引中的数据量很大时，一次查询可能需要返回大量的结果（一次查询中的限制条件比较模糊时会出现这种情况），这会导致网络和内存资源的浪费。为了解决这个问题，ES提供了自动滚动机制。自动滚动允许将查询结果分成多个分片，每次只返回一部分结果，然后再逐步滚动到下一个分片，直到所有结果都被返回。这样可以减少网络和内存的负担，提高查询效率。

过期：当索引中的数据不再需要时，为了释放存储空间，可以将其标记为过期。过期的数据不会立即被删除，而是在后台定期进行清理。ES提供了TTL（Time to Live）机制，允许为索引中的每个文档设置过期时间。一旦文档过期，ES会自动删除它。这样可以避免索引数据占用过多的存储空间，同时也可以保护用户的隐私。

### Term

在ES中，term是一种查询方式，用于精确匹配某个字段的值。它是一种基于词项的查询方式，只会匹配精确的词项，不会进行分词处理。

具体来说，term查询会在指定的字段中查找与查询词完全匹配的文档，不会对查询词进行分词处理。例如，如果查询词是“apple”，那么只会匹配字段中包含“apple”的文档，而不会匹配包含“apples”或“apple pie”的文档。

term查询适用于需要精确匹配某个字段值的场景，例如匹配某个特定的ID或关键字。但是需要注意的是，由于term查询不进行分词处理，因此它不适用于文本搜索场景。在文本搜索场景中，通常需要使用match或phrase查询等方式，对查询词进行分词处理。

### Elasticsearch 的查询优化 “三十六计”

