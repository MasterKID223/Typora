## 分布式文件系统

参考：[第三章媒资管理模块 3分布式文件系统]

### MinIO

官网：[[https://min.io](https://min.io)]

中文：[[https://www.minio.org.cn/](https://www.minio.org.cn/)]  [[http://docs.minio.org.cn/docs/](http://docs.minio.org.cn/docs/)]

#### 安装和启动

[https://min.io/docs/minio/windows/index.html#procedure](https://min.io/docs/minio/windows/index.html#procedure)

1. 下载：

```
https://dl.min.io/server/minio/release/windows-amd64/minio.exe
```

2. 可以把下载好的minio.exe（minio server）添加到环境变量中。

启动minio server

```
.\minio.exe server C:\minio --console-address :9090
```

其中，`C:\minio`是文件保存路径。

3. 应用连接MinIO server

浏览器连接：`http://127.0.0.1:9090`

4. 安装minio client（可选）

```
https://dl.min.io/client/mc/release/windows-amd64/mc.exe
```

#### docker中MinIO的使用

[https://min.io/docs/minio/container/index.html#procedure](https://min.io/docs/minio/container/index.html#procedure)

[https://min.io/download#/docker](https://min.io/download#/docker)

1. 在容器中启动minio server

```
podman run -p 9000:9000 -p 9001:9001 minio/minio server /data --console-address ":9001"
```

或者

```
sudo docker run -p 9000:9000 -p 9001:9001 minio/minio server /data --console-address ":9001"
```

这个命令使用 `podman`（一个没有守护进程的Docker的替代方案）来运行MinIO服务器。让我们逐步分析这个命令的各个部分：

1. **podman run**: `podman` 的 `run` 命令用于创建并运行一个新的容器实例。
2. **-p 9000:9000**: 这是端口映射参数。它将容器的 `9000` 端口映射到宿主机的 `9000` 端口。MinIO默认在 `9000` 端口上运行，这允许你通过宿主机的 `9000` 端口访问它。
3. **-p 9001:9001**: 与上面的参数类似，但这是为MinIO的新控制台界面（Console）进行的端口映射，该控制台在版本 `RELEASE.2021-04-22T15-44-28Z` 之后被引入。
4. **minio/minio**: 这是要运行的Docker镜像的名称，它包含MinIO的代码。
5. **server /data**: 这告诉MinIO以服务器模式运行，并将其数据目录设置为容器内的 `/data` 路径。
6. **--console-address ":9001"**: 这是一个新的参数，它告诉MinIO在哪个地址和端口上启动其控制台服务。在这种情况下，它将在容器的 `9001` 端口上启动，这与我们之前为它映射的端口匹配。

##### podman

总之，这个命令使用 `podman` 在容器中运行MinIO服务，并同时为MinIO的主服务和新的控制台服务设置了端口映射。

`Podman`（Pod Manager tool）是一个开源的容器运行时工具，它可以在没有守护进程的情况下管理和运行OCI（Open Container Initiative）兼容的容器和容器镜像。这与Docker不同，Docker依赖于一个守护进程来管理和运行容器。

以下是关于Podman的一些关键点：

1. **无守护进程**：与Docker不同，Podman不需要长时间运行的守护进程。这减少了复杂性并提高了安全性。

2. **兼容Docker CLI**：Podman的命令行接口（CLI）是与Docker兼容的，这意味着对于许多常见的操作，你可以使用与Docker相同的命令，只需将`docker`替换为`podman`。

3. **Rootless运行**：Podman允许普通用户（非root用户）运行容器，而不需要特殊的权限或附加的守护进程。这增强了安全性。

4. **Pod的概念**：虽然你可以使用Podman来运行单个的容器，但它也引入了"Pod"的概念，其中可以运行多个容器，这与Kubernetes中的Pod概念类似。

5. **兼容性**：Podman容器和镜像是与Docker容器和镜像兼容的，因为它们都遵循OCI规范。

6. **与其他工具集成**：Podman与其他工具，如`Buildah`（用于构建容器镜像）和`Skopeo`（用于容器镜像的远程检索和存储），非常好地集成在一起。

7. **没有中央服务器**：由于Podman没有守护进程，因此它不需要中央服务器来运行或管理容器。每个Podman命令都是独立运行的。

8. **迁移到Kubernetes**：Podman可以生成Kubernetes的YAML定义，这有助于将容器化的应用程序从单机迁移到Kubernetes集群。

Podman提供了一种更简洁、更安全的方式来运行和管理容器，特别是对于那些希望避免Docker守护进程或在没有root权限的环境中运行容器的用户。

#### 虚拟机里使用Docker启minio

[https://blog.csdn.net/BThinker/article/details/125412751](https://blog.csdn.net/BThinker/article/details/125412751)

要在虚拟机中使用Docker启动MinIO服务并让主机可以访问它，您需要执行以下步骤：

1. **设置虚拟机**:
   
   根据您使用的虚拟化软件（如VirtualBox、VMware等），请确保虚拟机的网络设置是桥接模式或NAT模式，并确保您可以从主机ping通虚拟机。

2. **安装Docker**:

   在虚拟机中，首先安装Docker。您可以按照[Docker的官方安装指南](https://docs.docker.com/get-docker/)来进行安装。

3. **启动MinIO服务**:

   在虚拟机的Docker中启动MinIO服务：

   ```bash
   docker run -p 9000:9000 --name minio-instance \
     -e "MINIO_ROOT_USER=myaccesskey" \
     -e "MINIO_ROOT_PASSWORD=mysecretkey" \
     minio/minio server /data
   ```

   这将启动一个MinIO实例，并将其9000端口映射到虚拟机的9000端口。

4. **允许外部访问**:

   根据您的虚拟机操作系统，确保其防火墙允许从外部访问9000端口。例如，在使用`firewalld`的Linux系统上，您可以执行以下命令：

   ```bash
   sudo firewall-cmd --zone=public --add-port=9000/tcp --permanent
   sudo firewall-cmd --reload
   ```

5. **从主机访问MinIO服务**:

   打开浏览器或使用任何客户端，并向虚拟机的IP地址和9000端口发出请求。例如，如果虚拟机的IP地址是`192.168.1.100`，则访问：

   ```
   http://192.168.1.100:9000
   ```

   使用您为MinIO设置的访问密钥和秘密密钥登录。

6. **注意事项**:

   - 确保虚拟机的网络设置正确，并且您的主机和虚拟机之间没有任何阻止通信的网络策略或防火墙。
   - 如果您使用的是NAT模式，您可能需要进行端口转发，以便从主机访问虚拟机上的服务。

按照上述步骤，您应该可以从主机成功地访问虚拟机中的MinIO服务。

##### ==配置（成功访问）==

```shell
sudo docker run -p 9000:9000 -p 9090:9090 \
     --net=host \
     --name minio \
     -d --restart=always \
     -e "MINIO_ACCESS_KEY=minioadmin" \
     -e "MINIO_SECRET_KEY=minioadmin" \
     -v /home/mkid/software/minio/data:/data \
     -v /home/mkid/software/minio/config:/root/.minio \
     minio/minio server \
     /data --console-address ":9090" -address ":9000"
```

这个命令使用Docker来启动一个MinIO的实例。让我们逐步分析这个命令：

1. **sudo**: 使用超级用户权限来执行后面的命令。

2. **docker run**: 使用Docker运行一个新的容器。

3. **-p 9000:9000 -p 9090:9090**: 端口映射。这两个参数告诉Docker将容器内的9000和9090端口分别映射到主机的9000和9090端口。

4. **--net=host**: 使用主机的网络堆栈。这意味着容器将共享主机的网络名称空间。

5. **--name minio**: 为容器指定一个名称，即“minio”。

6. **-d**: 以分离模式运行容器，这意味着容器在后台运行。

7. **--restart=always**: 如果容器由于任何原因停止，Docker将总是尝试重新启动它。

8. **-e "MINIO_ACCESS_KEY=minioadmin" -e "MINIO_SECRET_KEY=minioadmin"**: 设置MinIO的访问和密钥环境变量。

9. **-v /home/mkid/software/minio/data:/data -v /home/mkid/software/minio/config:/root/.minio**: 这两个参数定义了卷挂载。它们告诉Docker将主机上的指定目录挂载到容器内的指定路径。这样，数据和配置将在主机上持久化。

10. **minio/minio server**: 指定使用的镜像并告诉容器以MinIO服务器模式运行。

11. **/data**: 告诉MinIO服务器将数据存储在容器内的`/data`目录中。

12. **--console-address ":9090"**: 指定MinIO控制台应绑定到容器内的9090端口。

13. **-address ":9000"**: 指定MinIO服务器应绑定到容器内的9000端口。

总的来说，这个命令启动了一个MinIO服务器的Docker容器实例，并设置了相应的访问密钥、密钥、网络设置和持久化存储。这个实例将使用主机网络，同时也映射了9000和9090这两个端口。

### Java连接minio

[https://min.io/docs/minio/linux/developers/java/minio-java.html#minio-java-quickstart](https://min.io/docs/minio/linux/developers/java/minio-java.html#minio-java-quickstart)

上传文件示例`FileUploader.java`：

```java
import io.minio.BucketExistsArgs;
import io.minio.MakeBucketArgs;
import io.minio.MinioClient;
import io.minio.UploadObjectArgs;
import io.minio.errors.MinioException;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

public class FileUploader {
  public static void main(String[] args)
      throws IOException, NoSuchAlgorithmException, InvalidKeyException {
    try {
      // Create a minioClient with the MinIO server playground, its access key and secret key.
      MinioClient minioClient =
          MinioClient.builder()
              .endpoint("https://play.min.io")
              .credentials("Q3AM3UQ867SPQQA43P2F", "zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG")
              .build();

      // Make 'asiatrip' bucket if not exist.
      boolean found =
          minioClient.bucketExists(BucketExistsArgs.builder().bucket("asiatrip").build());
      if (!found) {
        // Make a new bucket called 'asiatrip'.
        minioClient.makeBucket(MakeBucketArgs.builder().bucket("asiatrip").build());
      } else {
        System.out.println("Bucket 'asiatrip' already exists.");
      }

      // Upload '/home/user/Photos/asiaphotos.zip' as object name 'asiaphotos-2015.zip' to bucket
      // 'asiatrip'.
      minioClient.uploadObject(
          UploadObjectArgs.builder()
              .bucket("asiatrip")
              .object("asiaphotos-2015.zip")
              .filename("/home/user/Photos/asiaphotos.zip")
              .build());
      System.out.println(
          "'/home/user/Photos/asiaphotos.zip' is successfully uploaded as "
              + "object 'asiaphotos-2015.zip' to bucket 'asiatrip'.");
    } catch (MinioException e) {
      System.out.println("Error occurred: " + e);
      System.out.println("HTTP trace: " + e.httpTrace());
    }
  }
}
```

