## JSR303校验

依赖：

```xml
<dependency
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

### javax.validation.constraints

在javax.validation.constraints包下有很多这样的校验注解，直接使用注解定义校验规则即可。

<img src="./pic/image-20230920232353567.png" alt="image-20230920232353567" style="zoom:50%;" />

规则如下：

<img src="./pic/image-20230920232412216.png" alt="image-20230920232412216" style="zoom:50%;" />

### 自定义校验规则注解

参考：[[视频教程bilibili](https://www.bilibili.com/video/BV1gP4y1v7Bd)]

如果javax.validation.constraints包下的校验规则满足不了需求怎么办？这时就需要自定义校验注解。

在Spring Boot中，您可以自定义校验规则注解，通常借助于Hibernate Validator（Hibernate Validator是Bean Validation规范的一个实现）来实现自定义校验规则。下面是一个简单的步骤指南，以创建自定义的校验规则注解：

1. 创建一个自定义注解，用于定义您的校验规则。这个注解需要添加`@Constraint`注解，并指定一个关联的校验器类（Validator）。例如：

```java
import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.*;

@Documented
@Constraint(validatedBy = MyCustomValidator.class)
@Target({ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyCustomValidation {

    String message() default "自定义校验失败消息";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
```

2. 创建一个校验器类，实现`ConstraintValidator`接口，用于实际执行校验逻辑。例如：

```java
import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class MyCustomValidator implements ConstraintValidator<MyCustomValidation, String> {

    @Override
    public void initialize(MyCustomValidation constraintAnnotation) {
        // 初始化方法，通常为空
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        // 在这里编写自定义的校验逻辑，返回true表示校验通过，返回false表示校验失败
        if (value == null) {
            return false;
        }
        
        // 自定义校验逻辑示例：检查字符串是否以特定前缀开头
        return value.startsWith("custom_prefix");
    }
}
```

3. 在需要进行校验的类的字段上使用自定义注解。例如：

```java
public class MyEntity {

    @MyCustomValidation
    private String customField;

    // 其他字段和方法
}
```

4. 在Spring Boot应用程序中，您需要配置`LocalValidatorFactoryBean` bean，以便Spring Boot能够自动启用基于注解的校验。可以在配置类中进行配置，如下所示：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

@Configuration
public class ValidationConfig {

    @Bean
    public LocalValidatorFactoryBean validatorFactoryBean() {
        return new LocalValidatorFactoryBean();
    }
}
```

5. 最后，在需要校验的地方，您可以使用`@Valid`注解来触发校验，例如在Controller中的方法参数上：

```java
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.validation.annotation.Validated;

@RestController
@Validated
public class MyController {

    @PostMapping("/validate")
    public ResponseEntity<String> validateEntity(@Valid @RequestBody MyEntity myEntity) {
        // 处理验证通过的情况
        return ResponseEntity.ok("Validation passed");
    }
}
```

现在，当您提交请求时，Spring Boot将自动应用自定义校验规则，校验`MyEntity`对象的`customField`字段是否满足自定义规则。

这就是如何在Spring Boot中自定义校验规则注解的基本步骤。您可以根据需要自定义更复杂的校验逻辑和错误消息。

### ConstraintValidatorContext(一般用不到)

`ConstraintValidatorContext` 是 Java 中用于自定义校验器（Constraint Validator）执行校验时的上下文对象。它是在校验过程中提供有关校验执行环境和控制的一个重要接口，通常用于生成自定义校验错误消息、访问被校验的值以及执行其他与校验相关的操作。

`ConstraintValidatorContext` 接口定义了多种方法，用于支持校验器在校验过程中与校验上下文进行交互。一些常见的方法包括：

1. `buildConstraintViolationWithTemplate(String message)`：创建一个校验错误消息，可以将自定义消息模板传递给该方法，并返回一个 `ConstraintViolationBuilder` 对象，用于进一步定制错误消息的内容。

2. `disableDefaultConstraintViolation()`：禁用默认的校验错误消息，以便完全自定义错误消息。

3. `addConstraintViolation()`：将通过 `buildConstraintViolationWithTemplate` 创建的自定义校验错误消息添加到校验结果中。

4. `getDefaultConstraintMessageTemplate()`：获取默认的校验错误消息模板，通常是在注解上指定的默认消息。

5. `unwrap(Class<T> type)`：用于获取特定类型的校验上下文的扩展。

校验器可以使用 `ConstraintValidatorContext` 来构建和自定义校验错误消息，以及根据校验的上下文来采取不同的校验行为。这允许开发人员在校验过程中对错误消息进行个性化处理，以便更好地满足应用程序的需求。

通常，`ConstraintValidatorContext` 是通过自定义校验器类实现 `ConstraintValidator` 接口的 `isValid` 方法时传递给校验器的。这个上下文对象可用于创建和管理校验错误消息，以及对校验过程进行更高级的控制。

### 学成在线自定义校验注解的实现

首先在base工程下创建注解：

```java
package com.xuecheng.base.annotation;

import com.xuecheng.base.validator.MyCustomValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.*;

/**
 * @author mkid
 * @version 1.0
 * @description 自定义注解，用于定义自定义校验规则
 * @date 2023/9/23 16:52
 */

@Documented
@Constraint(validatedBy = MyCustomValidator.class)
@Target({ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyCustomValidation {

    String message() default "com.xuecheng.base.annotation.MyCustomValidation中的自定义校验注解";  // 注解上的message的值

    Class<?>[] groups() default {};  // 注解上groups属性的值，列表属性

    Class<? extends Payload>[] payload() default {};
}
```

在base工程下实现指定的`MyCustomValidator`校验器类：

```java
package com.xuecheng.base.validator;

import com.xuecheng.base.annotation.MyCustomValidation;
import org.apache.commons.lang.StringUtils;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

/**
 * @author mkid
 * @version 1.0
 * @description 自定义校验器类
 * @date 2023/9/23 17:12
 */
public class MyCustomValidator implements ConstraintValidator<MyCustomValidation, String> {

    @Override
    public void initialize(MyCustomValidation constraintAnnotation) {
        // 初始化方法，通常为空
    }

    /**
     *
     * @param value 是被注解的值
     * @param constraintValidatorContext
     * @return
     */
    @Override
    public boolean isValid(String value, ConstraintValidatorContext constraintValidatorContext) {
        // 在这里编写自定义的校验逻辑，返回true表示校验通过，返回false表示校验失败
        if (StringUtils.isEmpty(value)) {
            return false;
        }
        return true;
    }
}
```

在dto Bean类里加上注解：

```java
@Data
@ApiModel(value = "AddCourseDto", description = "新增课程基本信息")
public class AddCourseDto {

    @MyCustomValidation(groups = {ValidationGroups.Insert.class}, message = "自定义注解：课程名称不能为空")
//    @NotEmpty(groups = {ValidationGroups.Insert.class}, message = "添加课程名称不能为空")
//    @NotEmpty(groups = {ValidationGroups.Update.class}, message = "修改课程名称不能为空")
//    @NotEmpty(message = "课程名称不能为空")
    @ApiModelProperty(value = "课程名称", required = true)
    private String name;
    
    // ...
}

```

在Controller对应的路由里，添加Validated参数。

```java
@ApiOperation("新增课程基础信息")
@PostMapping("/course")
public CourseBaseInfoDto createCourseBase(@RequestBody @Validated({ValidationGroups.Insert.class}) AddCourseDto addCourseDto) {
    // 机构id，由于认证系统没有上线暂时硬编码
    Long companyId = 1232141425L;
    return courseBaseInfoService.createCourseBase(companyId, addCourseDto);
}
```

如果课程名称为空的话，请求被全局拦截器捕获`MethodArgumentNotValidException`异常。