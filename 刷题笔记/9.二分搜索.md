## 二分搜索模板

### 直接返回mid的模板

题目: [[leetcode](https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)]

二分查找是一种高效的搜索算法，用于在有序数组中查找特定元素的位置。以下是二分查找的通用模板：

```python
def binary_search(nums, target):
    # 定义搜索范围的左右边界
    left, right = 0, len(nums) - 1
    
    # 当左边界小于等于右边界时，进行查找
    while left <= right:
        # 计算中间元素的索引
        mid = left + (right - left) // 2
        
        # 如果中间元素等于目标值，则返回索引
        if nums[mid] == target:
            return mid
        # 如果中间元素大于目标值，则在左半部分继续查找
        elif nums[mid] > target:
            right = mid - 1
        # 如果中间元素小于目标值，则在右半部分继续查找
        else:
            left = mid + 1
    
    # 如果未找到目标值，则返回 -1
    return -1
```

这个模板包含以下几个关键步骤：

1. 初始化左右边界，通常左边界为数组起始位置，右边界为数组结束位置。
2. 在 while 循环中，判断左边界是否小于等于右边界，确保搜索范围有效。
3. 在循环中，计算中间元素的索引。
4. 检查中间元素是否等于目标值，如果是，则返回中间元素的索引。
5. 如果中间元素大于目标值，则将右边界移到中间元素的左边一位，缩小搜索范围。
6. 如果中间元素小于目标值，则将左边界移到中间元素的右边一位，缩小搜索范围。
7. 如果循环结束时仍未找到目标值，则返回 -1，表示目标值不存在于数组中。

这个模板适用于普通的二分查找，可以在有序数组中查找指定的目标值。

<hr>

在计算中间元素的索引时，我们需要考虑到当前搜索范围的左边界。使用 `mid = left + (right - left) // 2` 是为了确保中间元素相对于当前搜索范围的正确位置。

考虑以下情况：

假设 `left = 3`，`right = 7`。如果我们简单地使用 `mid = (right - left) // 2`，那么 `mid` 的值将会是 `(7 - 3) // 2 = 2`，这样就会得到错误的中间索引。

正确的计算应该是当前搜索范围的起始位置 `left` 加上搜索范围的一半。因此，我们需要将 `(right - left)` 确保为当前搜索范围的长度，然后再将其除以 2。这样才能保证 `mid` 在当前搜索范围中的正确位置。

因此，`mid = left + (right - left) // 2` 是二分查找中常见且正确的计算方式。

<hr>

`mid = (left + right)// 2` 是计算中间元素索引的一种方式，它的逻辑上是可行的，但是在极端情况下可能会导致整数溢出。

当搜索范围的左边界 `left` 和右边界 `right` 非常大的时候，`left + right` 的结果可能会超出整数的表示范围，导致溢出。特别是在一些语言中，整数的表示范围是有限的，如32位或64位整数。

为了避免整数溢出的问题，我们一般会采用 `mid = left + (right - left) // 2` 这种形式，先计算出两个索引之间的差值，再除以 2，这样可以确保计算的安全性。

因此，虽然 `mid = (left + right)// 2` 在一般情况下也是有效的，但为了确保程序的鲁棒性，建议采用 `mid = left + (right - left) // 2` 这种形式进行中间索引的计算。

### 结合其他逻辑的模板

题目：[[leetcode](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked)]

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

