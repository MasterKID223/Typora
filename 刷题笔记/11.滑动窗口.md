## 滑动窗口

所有题目来自leetcode的回答：https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/3982/hua-dong-chuang-kou-by-powcai

会员题没有列出来。

### 最长无重复子串

题目：https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        if (n == 0) return 0;
        Map<Character, Integer> map = new HashMap<>();
        int res = 0, left = 0;
        for (int i = 0; i < n; i ++) {
            if (map.containsKey(s.charAt(i))) {
                left = Math.max(left, map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i), i);
            res = Math.max(res, i - left  + 1);
        }
        return res;
    }
}
```

### 最小覆盖子串

题目：https://leetcode.cn/problems/minimum-window-substring/description/

```java
class Solution {

    Map<Character, Integer> cnts = new HashMap<>();
    Map<Character, Integer> cntt = new HashMap<>();

    public String minWindow(String s, String t) {
        int ls = s.length(), lt = t.length();
        int milen = Integer.MAX_VALUE, st = 0,  ed = 0, mist = 0, mied = 0;
        boolean isNull = false;
        for (int i = 0 ; i < lt; i ++) {
            cntt.put(t.charAt(i), cntt.getOrDefault(t.charAt(i), 0) + 1);
        }
        while (ed < ls) {
            if (cntt.containsKey(s.charAt(ed))) {
                cnts.put(s.charAt(ed), cnts.getOrDefault(s.charAt(ed), 0) + 1);
                while (check()) {  // 这里是while，一步更新到第二个在cntt里的字符，过滤掉无用字符
                    isNull = true;
                    if (milen > ed - st + 1) {
                        milen = ed - st + 1;
                        mist = st;
                        mied = ed;
                    }
                    if (cntt.containsKey(s.charAt(st))) {
                        cnts.put(s.charAt(st), cnts.getOrDefault(s.charAt(st), 0) - 1);
                    }
                    st ++;
                }
            }
            ed ++;
        }
        if (!isNull) return "";
        return s.substring(mist, mied + 1);
    }

    private boolean check() {
        Iterator iter = cntt.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            Character key = (Character) entry.getKey();
            Integer val = (Integer) entry.getValue();
            if (cnts.getOrDefault(key, 0) < val) return false;
        }
        return true;
    }
}
```

### 串联所有单词的子串

题目：https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/

题解：https://leetcode.cn/problems/substring-with-concatenation-of-all-words/solutions/3825/chuan-lian-suo-you-dan-ci-de-zi-chuan-by-powcai

```java
// 对words中的所有单词，维护一个单词计数map
// 串联子串中保证了每个子单词的原字符顺序不变
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        int ls = s.length(), n = words.length;
        int lw = n * words[0].length(), oneLen = words[0].length();
        List<Integer> res = new ArrayList<>();
        if (lw > ls) return res;
        Map<String, Integer> wordsMap = new HashMap<>();
        for (int i = 0; i < n; i ++) {
            wordsMap.put(words[i], wordsMap.getOrDefault(words[i], 0) + 1);
        }
        for (int i = 0; i < ls - lw + 1; i ++) {  //  i < ls - lw + 1，保证能枚举到最后一个窗口的第一个下标位置
            Map<String, Integer> tmpMap = new HashMap<>();
            for (int j = i; j < i + lw; j += oneLen) {
                String subStr = s.substring(j, j + oneLen);
                tmpMap.put(subStr, tmpMap.getOrDefault(subStr, 0) + 1);
            }
            if (wordsMap.equals(tmpMap)) res.add(i);
        }
        return res; 
    }
}
```

优化：（常规的滑动窗口思路，和最小覆盖子串的代码逻辑相似）

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        int ls = s.length(), n = words.length;
        int lw = n * words[0].length(), oneLen = words[0].length();
        List<Integer> res = new ArrayList<>();
        if (lw > ls) return res;
        Map<String, Integer> wordsMap = new HashMap<>();
        for (int i = 0; i < n; i ++) {
            wordsMap.put(words[i], wordsMap.getOrDefault(words[i], 0) + 1);
        }
        for (int i = 0; i < oneLen; i ++) {  // 保证枚举到所有单词[0...oneLen], [1...oneLen + 1], ...
            int st = i, ed = i, cnt = 0;
            Map<String, Integer> tmpMap = new HashMap<>();
            while (ed < ls - oneLen + 1) {  // 同解法一的判断
                String subStr = s.substring(ed, ed + oneLen);
                tmpMap.put(subStr, tmpMap.getOrDefault(subStr, 0) + 1);
                ed += oneLen;
                cnt ++;  // 当前窗口里有几个单词
                while(tmpMap.getOrDefault(subStr, 0) > wordsMap.getOrDefault(subStr, 0)) {
                    // 窗口里的单词并不在wordsMap里，移动窗口
                    // 或者，窗口里当前单词重复出现了，移动窗口
                    String stStr = s.substring(st, st + oneLen);  // 窗口里最左边的单词
                    tmpMap.put(stStr, tmpMap.getOrDefault(stStr, 0) - 1);
                    st += oneLen;
                    cnt --;
                }
                if (cnt == n) res.add(st);
            }
        }
        return res;
    }
}
```

再优化（直接跳过不在words里的单词和窗口）：

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        int ls = s.length(), n = words.length;
        int lw = n * words[0].length(), oneLen = words[0].length();
        List<Integer> res = new ArrayList<>();
        if (lw > ls) return res;
        Map<String, Integer> wordsMap = new HashMap<>();
        for (int i = 0; i < n; i ++) {
            wordsMap.put(words[i], wordsMap.getOrDefault(words[i], 0) + 1);
        }
        for (int i = 0; i < oneLen; i ++) {  // 保证枚举到所有单词[0...oneLen], [1...oneLen + 1], ...
            int st = i, ed = i, cnt = 0;
            Map<String, Integer> tmpMap = new HashMap<>();
            while (ed < ls - oneLen + 1) {  // 同解法一的判断
                String subStr = s.substring(ed, ed + oneLen);
                ed += oneLen;
                if (!wordsMap.containsKey(subStr)) {
                    /**
                        当前窗口的当前单词不是words里的单词，肯定不符合题意，更新窗口。
                        题中要求所有串联单词必须挨在一起，这个判断过滤掉不挨在一起的窗口
                     */
                    cnt = 0;
                    st = ed;
                    tmpMap.clear();
                    continue;
                }
                tmpMap.put(subStr, tmpMap.getOrDefault(subStr, 0) + 1);
                cnt ++;  // 当前窗口里有几个单词
                while(tmpMap.getOrDefault(subStr, 0) > wordsMap.getOrDefault(subStr, 0)) {
                    // 窗口里的单词并不在wordsMap里，移动窗口
                    // 或者，窗口里当前单词重复出现了，移动窗口
                    String stStr = s.substring(st, st + oneLen);  // 窗口里最左边的单词
                    tmpMap.put(stStr, tmpMap.getOrDefault(stStr, 0) - 1);
                    st += oneLen;
                    cnt --;
                }
                if (cnt == n) res.add(st);
            }
        }
        return res;
    }
}
```

### 长度最小的子数组

题目：https://leetcode.cn/problems/minimum-size-subarray-sum/description/

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int milen = Integer.MAX_VALUE, st = 0, ed = 0, sum = 0;
        boolean isNull = false;
        while (ed < n) {
            sum += nums[ed];
            while (sum >= target) {
                isNull = true;
                if (milen > ed - st + 1) {
                    milen = ed - st + 1;
                }
                sum -= nums[st];
                st ++;
            }
            ed ++;
        }
        if (!isNull) return 0;
        return milen;
    }
}
```

### 滑动窗口最大值

题目：https://leetcode.cn/problems/sliding-window-maximum/description/

```java

```

### 字符串的排列

题目：https://leetcode.cn/problems/permutation-in-string/description/

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int ls1 = s1.length(), ls2 = s2.length();
        if (ls1 > ls2) return false;
        int[] cnt1 = new int[26], cnt2 = new int[26];
        for (int i = 0; i < ls1; i ++) {
            cnt1[s1.charAt(i) - 'a'] ++;
            cnt2[s2.charAt(i) - 'a'] ++;
        }
        if (Arrays.equals(cnt1, cnt2)) return true;
        for (int i = ls1; i < ls2; i ++) {
            cnt2[s2.charAt(i - ls1) - 'a'] --;
            cnt2[s2.charAt(i) - 'a'] ++;
            if (Arrays.equals(cnt1, cnt2)) return true;
        }
        return false;
    }
}
```

### 最小区间

题目：https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/description/

```java

```

