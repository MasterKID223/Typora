## 刷题模板-Java版

### 搜索与图论

#### 树与图的存储

树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。

(1) 邻接矩阵：g[a][b] 存储边a->b

(2) 邻接表：

头插法建邻接表。

```java
public class Graph {
    private static final int N = 100;  // 假设N是图中点的最大数量
    private int[] h = new int[N];
    private int[] e = new int[N];  // 当前链表里的第几条边，对应图中节点的编号是多少
    private int[] ne = new int[N];
    private int idx;

    public Graph() {
        idx = 0;
        Arrays.fill(h, -1); // 使用Arrays.fill来初始化数组
    }

    // 添加一条边a->b
    public void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }
}
```

这三行代码是用于在图的邻接表表示中添加一条从顶点`a`到顶点`b`的边。在理解这些代码之前，首先要了解邻接表的结构和工作原理。

邻接表是图的一种常用表示方法，特别适用于表示稀疏图。对于每个顶点，它维护一个链表，链表中的每个节点表示从该顶点出发可以直接到达的其他顶点。

在这段代码中，`h`, `e`, `ne`, 和 `idx` 是用于实现邻接表的关键数组：

- `h[]`: 存储每个顶点的链表头。对于顶点`k`，`h[k]`是链表中第一个节点的索引。
- `e[]`: 存储边的目的顶点。`e[i]`是第`i`个添加的边的目的顶点。
- `ne[]`: 存储同一个链表中的下一个元素的索引。如果`ne[i]`是`j`，那么在链表中`i`后面的元素是`j`。
- `idx`: 是一个计数器，用于追踪当前已经添加了多少条边，同时也作为这些数组的索引。

具体到这三行代码：

1. `e[idx] = b;`：将顶点`b`存储在数组`e`中的`idx`位置，表示这条边的目的地是顶点`b`。

2. `ne[idx] = h[a];`：将当前顶点`a`的链表头（即`h[a]`）作为新元素的下一个元素存储在`ne`中。这样做是为了将新边插入到链表的头部。

3. `h[a] = idx++;`：更新顶点`a`的链表头为这条新边，然后增加`idx`的值，为下一次添加边做准备。

简而言之，这段代码是在顶点`a`的邻接链表的头部插入一个新元素，这个新元素代表了一条到顶点`b`的边。通过这种方式，可以高效地存储和遍历图中的所有边。